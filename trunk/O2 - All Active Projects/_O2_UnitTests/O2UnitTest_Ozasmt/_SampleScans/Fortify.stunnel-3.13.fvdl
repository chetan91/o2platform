<?xml version="1.0" encoding="UTF-8"?>
<FVDL xmlns="xmlns://www.fortifysoftware.com/schema/fvdl1.3"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2">
<!--<FVDL>-->
  <CreatedTS date="2005-09-22" time="10:19:53"/>
  <Build>
    <NumberFiles>9</NumberFiles>
    <LOC>2899</LOC>
    <SourceBasePath>/home/jw/Research/SecureProgrammingWorkshop/Examples/stunnel-3.13</SourceBasePath>
  </Build>
  <Vulnerabilities>
    <Vulnerability>
      <ClassInfo>
        <ClassID>635A356B-CF51-420F-956E-54E0933AB305</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>7BAB28F30A3362EBA1644C5BAC7C47AA</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="EDA0E38AA30B78DA79FCFA2A631F90BF29AAE6EC">
            <FunctionCall>
              <SourceLocation path="pty.c" line="76"
                  lineEnd="76" colStart="0" colEnd="0" snippet="pty.c:76:76"/>
              <Function name="strncpy"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2CB8A870-C25A-4E25-AE37-15D864655F64</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>7788095A2E0A69AE950B71DB9CAE8DC9</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="2876088CCB71BD0C4B9BAE434082FA77276DFE74">
            <FunctionCall>
              <SourceLocation path="protocol.c" line="169"
                  lineEnd="169" colStart="0" colEnd="0" snippet="protocol.c:169:169"/>
              <Function name="read"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>948FF8C7-B5FF-4D31-876B-1F2B7E142F68</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>90E8CE9EB53C86353FFFEF1F4572452D</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="F3EDA521D14DA778C7DA5FCB88F65E2FBE0F35D0">
            <FunctionCall>
              <SourceLocation path="protocol.c" line="186"
                  lineEnd="186" colStart="0" colEnd="0" snippet="protocol.c:186:186"/>
              <Function name="sscanf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>15677FEB-E366-4407-A0C7-31B92F68F226</ClassID>
        <Type>Format String</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>45E2FC5608BB28D042C981931A295B1D</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="F3EDA521D14DA778C7DA5FCB88F65E2FBE0F35D0">
            <FunctionCall>
              <SourceLocation path="protocol.c" line="186"
                  lineEnd="186" colStart="0" colEnd="0" snippet="protocol.c:186:186"/>
              <Function name="sscanf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>37800F72-E40D-49B6-948D-CCA743075F85</ClassID>
        <Type>Format String</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>35F003873680CD411641948476013F37</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="FD4745A62E9094EC6E0D6F65E411BE491AD0DD2A">
            <FunctionCall>
              <SourceLocation path="protocol.c" line="145"
                  lineEnd="145" colStart="0" colEnd="0" snippet="protocol.c:145:145"/>
              <Function name="vsnprintf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2ABE24EC-297C-4AC3-B441-197D75177A55</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>2D47D63F06142A43BF68489F896D17E7</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="FD4745A62E9094EC6E0D6F65E411BE491AD0DD2A">
            <FunctionCall>
              <SourceLocation path="protocol.c" line="145"
                  lineEnd="145" colStart="0" colEnd="0" snippet="protocol.c:145:145"/>
              <Function name="vsnprintf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>256FF15F-1828-4657-9E4C-9D606DABBEAA</ClassID>
        <Type>Often Misused: Authentication</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>6DF6D1269D5CB9A55FEABC2AAC1B2152</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="B1FF69BAFD78D5BA665AF14D3C39A0409178613F">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="898"
                  lineEnd="898" colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
              <Function name="gethostbyname"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>95414A7F-C5A3-4E3C-BC41-0630BDED9E36</ClassID>
        <Type>Unchecked Return Value</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>10E669FCC85E851DC44B8614ABD1D767</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="BDC31B22E10EAF0A9318492AA63319F9164ACA41">
            <FunctionCall>
              <SourceLocation path="pty.c" line="229"
                  lineEnd="229" colStart="0" colEnd="0" snippet="pty.c:229:229"/>
              <Function name="ioctl"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>95414A7F-C5A3-4E3C-BC41-0630BDED9E36</ClassID>
        <Type>Unchecked Return Value</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>40B856A3BDBA2868DAD6DA0DFD30E916</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="8EC339C78DDAFE405350F42FBA8A24A4678ADF84">
            <FunctionCall>
              <SourceLocation path="pty.c" line="253"
                  lineEnd="253" colStart="0" colEnd="0" snippet="pty.c:253:253"/>
              <Function name="ioctl"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>37800F72-E40D-49B6-948D-CCA743075F85</ClassID>
        <Type>Format String</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>E8C15FE3B104BEF94F97553F27DDD461</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="71A1576062A9F2B2B5E429989BA5C4EA56BFBEA5">
            <FunctionCall>
              <SourceLocation path="log.c" line="152"
                  lineEnd="152" colStart="0" colEnd="0" snippet="log.c:152:152"/>
              <Function name="vsnprintf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2ABE24EC-297C-4AC3-B441-197D75177A55</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>1F5F38BBEAAB7A364C56208F60C4344B</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="71A1576062A9F2B2B5E429989BA5C4EA56BFBEA5">
            <FunctionCall>
              <SourceLocation path="log.c" line="152"
                  lineEnd="152" colStart="0" colEnd="0" snippet="log.c:152:152"/>
              <Function name="vsnprintf"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>20FF3BA7-0457-463A-A96F-25BC7457EC0C</ClassID>
        <Type>Unchecked Return Value</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>1191859BCBD654C7A42A179E57F13D40</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="80D1B78101E5C767D0799497C8AF654BBB25642B">
            <FunctionCall>
              <SourceLocation path="log.c" line="164"
                  lineEnd="164" colStart="0" colEnd="0" snippet="log.c:164:164"/>
              <Function name="fflush"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>57635DC2-A681-4A15-8A66-59364C65D332</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>36BD21C71EE81B4A48809D731DEB61EA</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="25247A273602B9A0FB8EFE0A4DCE6A80C65CCB59">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="692"
                  lineEnd="692" colStart="0" colEnd="0" snippet="stunnel.c:692:692"/>
              <Function name="strncat"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2CB8A870-C25A-4E25-AE37-15D864655F64</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>F5DEE9D5128521B4F62A4284C09062E5</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="C8A8055AAF58E8D707B0E58B6651F1864A091B36">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="782"
                  lineEnd="782" colStart="0" colEnd="0" snippet="stunnel.c:782:782"/>
              <Function name="read"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>6F195230-103C-42F3-930D-8ACA743407EE</ClassID>
        <Type>Inconsistent Implementations</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>0F9DC545A353B9EE8124D96E42DD1E55</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="763AAC61121DEDE04225DDE9F769A7A57EC60095">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="246"
                  lineEnd="246" colStart="0" colEnd="0" snippet="stunnel.c:246:246"/>
              <Function name="getopt"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>7D8CF10B-0535-4B3B-B899-F7885493EF39</ClassID>
        <Type>Unchecked Return Value</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>AE6466E6942D1BA86F18301B5F76CCB2</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="EF4A4B39F6474C1D39358F2EE0F888637D462BFC">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="550"
                  lineEnd="550" colStart="0" colEnd="0" snippet="stunnel.c:550:550"/>
              <Function name="unlink"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>34144386-FFE3-4848-B516-79131B80AD88</ClassID>
        <Type>Often Misused: Privilege Management</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>4217F55B952938DF8D55F78EFD7CAEB0</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="5A896453E0852FBEF93F41CE84BEE0522432C912">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="612"
                  lineEnd="612" colStart="0" colEnd="0" snippet="stunnel.c:612:612"/>
              <Function name="setgid"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>34144386-FFE3-4848-B516-79131B80AD88</ClassID>
        <Type>Often Misused: Privilege Management</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>F474EA906AA333613BD1C96957BAB36A</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="E0D9559F89D8AB1520F17C64AA54FA4FA8E24F4F">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="638"
                  lineEnd="638" colStart="0" colEnd="0" snippet="stunnel.c:638:638"/>
              <Function name="setuid"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>57635DC2-A681-4A15-8A66-59364C65D332</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>53FB313AE0886949C47634E802A62F08</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="A6057A09CD34582A3007455507BD99930A7B45E6">
            <FunctionCall>
              <SourceLocation path="ssl.c" line="663"
                  lineEnd="663" colStart="0" colEnd="0" snippet="ssl.c:663:663"/>
              <Function name="memcpy"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>57635DC2-A681-4A15-8A66-59364C65D332</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>3234C626C4A55BABAE39450E4C0DDB8F</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="321A237D99C1EB549B042E0A023B1FA1C96D8353">
            <FunctionCall>
              <SourceLocation path="ssl.c" line="691"
                  lineEnd="691" colStart="0" colEnd="0" snippet="ssl.c:691:691"/>
              <Function name="memcpy"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2CB8A870-C25A-4E25-AE37-15D864655F64</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>98112CE746461C4F036C39A88F8B4BA2</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="D65064B69ADF294C02710364C1A78FD208E14F92">
            <FunctionCall>
              <SourceLocation path="ssl.c" line="716"
                  lineEnd="716" colStart="0" colEnd="0" snippet="ssl.c:716:716"/>
              <Function name="read"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>57635DC2-A681-4A15-8A66-59364C65D332</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>61EC132B402A9D4F4E111B9FAAB80969</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="23126348ECE46236AA55B2A473ECBCB23EC1EB89">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="164"
                  lineEnd="164" colStart="0" colEnd="0" snippet="stunnel.c:164:164"/>
              <Function name="strncat"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>57635DC2-A681-4A15-8A66-59364C65D332</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>2.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>EC9B0F6F3F0C8D8A6911A30A4417B406</InstanceID>
        <InstanceSeverity>2.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Local>
          <SourceRef sourceRefID="99E9421FABD5BA59EF2F17CA7964F8E662FA3E7A">
            <FunctionCall>
              <SourceLocation path="stunnel.c" line="165"
                  lineEnd="165" colStart="0" colEnd="0" snippet="stunnel.c:165:165"/>
              <Function name="strncat"/>
            </FunctionCall>
          </SourceRef>
        </Local>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>DAE45D1C-5AC1-4FBF-9C0A-562A2CE5B482</ClassID>
        <Type>Integer Overflow</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>2C1ACEF22816F193DE0298A00EBC1613</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source outArg="return" ruleID="A1796E75-AE27-4C8B-9BB6-F2B0D9985B61">
            <SourceRef sourceRefID="B1FF69BAFD78D5BA665AF14D3C39A0409178613F">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="898" lineEnd="898"
                    colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
                <Function name="gethostbyname"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="host2num"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="DAE45D1C-5AC1-4FBF-9C0A-562A2CE5B482">
            <SourceRef sourceRefID="7FA895CCF27FF1956DFB94C7EA4BA857BA4D2CDC">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="1007" lineEnd="1007"
                    colStart="0" colEnd="0" snippet="stunnel.c:1007:1007"/>
                <Function name="malloc"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="alloc"/>
            </Context>
          </Sink>
          <Path>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="898" lineEnd="898"
                  colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
                  <Variable name="h"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="903" lineEnd="903"
                  colStart="0" colEnd="0" snippet="stunnel.c:903:903"/>
                  <Variable name="tab"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
            <Node inArg="1">
              <SourceRef sourceRefID="2CBD87CA65D2718D5048848951AE3A632826881B">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="906" lineEnd="906"
                  colStart="0" colEnd="0" snippet="stunnel.c:906:906"/>
                  <Function name="alloc"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>86C7916D-A73B-4EBE-A235-9E570095EE66</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>B19346F661216AB6AFB2A8DD1FC2687D</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source outArg="return" ruleID="A1796E75-AE27-4C8B-9BB6-F2B0D9985B61">
            <SourceRef sourceRefID="B1FF69BAFD78D5BA665AF14D3C39A0409178613F">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="898" lineEnd="898"
                    colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
                <Function name="gethostbyname"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="host2num"/>
            </Context>
          </Source>
          <Sink ruleID="86C7916D-A73B-4EBE-A235-9E570095EE66">
            <SourceRef>
              <Statement type="assignment">
                <SourceLocation path="stunnel.c"
                    line="1012" lineEnd="1012"
                    colStart="0" colEnd="0" snippet="stunnel.c:1012:1012"/>
              </Statement>
            </SourceRef>
            <Context>
              <Function name="alloc"/>
            </Context>
          </Sink>
          <Path>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="898" lineEnd="898"
                  colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
                  <Variable name="h"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="903" lineEnd="903"
                  colStart="0" colEnd="0" snippet="stunnel.c:903:903"/>
                  <Variable name="tab"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
            <Node inArg="1" ruleID="86C7916D-A73B-4EBE-A235-9E570095EE66">
              <SourceRef sourceRefID="2CBD87CA65D2718D5048848951AE3A632826881B">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="906" lineEnd="906"
                  colStart="0" colEnd="0" snippet="stunnel.c:906:906"/>
                  <Function name="alloc"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="host2num"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>28424EC3-FFAC-40C0-94D9-3D8283B2F57C</ClassID>
        <Type>Buffer Overflow</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>20F4C47463E4832CAAC8C1DED09F346E</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source outArg="1" ruleID="39DDF4FD-5A7A-4BFF-AEC4-05A8232615B1">
            <SourceRef sourceRefID="C8A8055AAF58E8D707B0E58B6651F1864A091B36">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="782" lineEnd="782"
                    colStart="0" colEnd="0" snippet="stunnel.c:782:782"/>
                <Function name="read"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="auth_user"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="28424EC3-FFAC-40C0-94D9-3D8283B2F57C">
            <SourceRef sourceRefID="D6EFFCEED49F8534CACC6C3107295C32355EB1F7">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="792" lineEnd="792"
                    colStart="0" colEnd="0" snippet="stunnel.c:792:792"/>
                <Function name="sscanf"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="auth_user"/>
            </Context>
          </Sink>
          <Path/>
          <TaintFlags>
            <TaintFlag name="STREAM"/>
            <TaintFlag name="NOT_NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>A5A573EC-B5AF-4A6F-B154-67856C9F29B6</ClassID>
        <Type>String Termination Error</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>A38E1CFE67F0173E582803EBFC01EBED</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source outArg="1" ruleID="39DDF4FD-5A7A-4BFF-AEC4-05A8232615B1">
            <SourceRef sourceRefID="C8A8055AAF58E8D707B0E58B6651F1864A091B36">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="782" lineEnd="782"
                    colStart="0" colEnd="0" snippet="stunnel.c:782:782"/>
                <Function name="read"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="auth_user"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
            <SourceRef sourceRefID="EC4A6A280BB8AA54FC75C35BF5E1160DCA1B6FA9">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="797" lineEnd="797"
                    colStart="0" colEnd="0" snippet="stunnel.c:797:797"/>
                <Function name="strcmp"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="auth_user"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="2" ruleID="2B7CC9F2-A052-46BC-87F3-8621B4787ED7">
              <SourceRef sourceRefID="D6EFFCEED49F8534CACC6C3107295C32355EB1F7">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="792" lineEnd="792"
                  colStart="0" colEnd="0" snippet="stunnel.c:792:792"/>
                  <Function name="sscanf"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="auth_user"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="STREAM"/>
            <TaintFlag name="NOT_NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>CC65B852-C8FF-4FD2-9515-39BC8F12520F</ClassID>
        <Type>Setting Manipulation</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>A4838F4961D88DE2833B281AFC8F56BE</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source outArg="return" ruleID="73602E8D-0EC9-46B2-98C2-62E51F441B71">
            <SourceRef sourceRefID="8764D870D8DAD028717767CA13C8472ECC3EF6CE">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="606" lineEnd="606"
                    colStart="0" colEnd="0" snippet="stunnel.c:606:606"/>
                <Function name="getgrnam"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="listen_local"/>
            </Context>
          </Source>
          <Sink inArg="1" ruleID="CC65B852-C8FF-4FD2-9515-39BC8F12520F">
            <SourceRef sourceRefID="55E01F34CA929B08FB0F23B624810D3D484769A0">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="617" lineEnd="617"
                    colStart="0" colEnd="0" snippet="stunnel.c:617:617"/>
                <Function name="setgroups"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="listen_local"/>
            </Context>
          </Sink>
          <Path>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="606" lineEnd="606"
                  colStart="0" colEnd="0" snippet="stunnel.c:606:606"/>
                  <Variable name="gr"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="listen_local"/>
              </Context>
            </Node>
            <Node>
              <SourceRef>
                <Statement type="assignment">
                  <SourceLocation path="stunnel.c"
                  line="616" lineEnd="616"
                  colStart="0" colEnd="0" snippet="stunnel.c:616:616"/>
                  <Variable name="gr_list"/>
                </Statement>
              </SourceRef>
              <Context>
                <Function name="listen_local"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="NULL_TERMINATED"/>
            <TaintFlag name="FILE_SYSTEM"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>43549EB235330661003B77018B721A9A</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="0" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="delete_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="776763F5AAACC2D341114E9121BA1ED85B14B35A">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="568" lineEnd="568"
                    colStart="0" colEnd="0" snippet="stunnel.c:568:568"/>
                <Function name="unlink"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="delete_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="delete_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>7FFC8E84FFC55DD8C5E19D073174049E</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="1" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="delete_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="776763F5AAACC2D341114E9121BA1ED85B14B35A">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="568" lineEnd="568"
                    colStart="0" colEnd="0" snippet="stunnel.c:568:568"/>
                <Function name="unlink"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="delete_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="1" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="delete_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>14690628-80D2-4B94-9677-B69C71BF91AF</ClassID>
        <Type>Process Control</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>1F1F4BE9DC314454F4D6422CDA62C570</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="1" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="14690628-80D2-4B94-9677-B69C71BF91AF">
            <SourceRef sourceRefID="8CED15510CFBDAE3990B5DCD9A5781B5204BCF56">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="695" lineEnd="695"
                    colStart="0" colEnd="0" snippet="stunnel.c:695:695"/>
                <Function name="execvp"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="1" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="connect_local"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>14690628-80D2-4B94-9677-B69C71BF91AF</ClassID>
        <Type>Process Control</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>63310D88A90A615CCEBEBC844D105886</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="0" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="14690628-80D2-4B94-9677-B69C71BF91AF">
            <SourceRef sourceRefID="8CED15510CFBDAE3990B5DCD9A5781B5204BCF56">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="695" lineEnd="695"
                    colStart="0" colEnd="0" snippet="stunnel.c:695:695"/>
                <Function name="execvp"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="connect_local"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>14690628-80D2-4B94-9677-B69C71BF91AF</ClassID>
        <Type>Process Control</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>76B193488172FF85FFD2A212186E3F73</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="1" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Source>
          <Sink inArg="1" ruleID="14690628-80D2-4B94-9677-B69C71BF91AF">
            <SourceRef sourceRefID="8CED15510CFBDAE3990B5DCD9A5781B5204BCF56">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="695" lineEnd="695"
                    colStart="0" colEnd="0" snippet="stunnel.c:695:695"/>
                <Function name="execvp"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="1" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="connect_local"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>14690628-80D2-4B94-9677-B69C71BF91AF</ClassID>
        <Type>Process Control</Type>
        <DefaultSeverity>4.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>E6A906C5349A04B48523EE36E7387A5B</InstanceID>
        <InstanceSeverity>4.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="0" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Source>
          <Sink inArg="1" ruleID="14690628-80D2-4B94-9677-B69C71BF91AF">
            <SourceRef sourceRefID="8CED15510CFBDAE3990B5DCD9A5781B5204BCF56">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="695" lineEnd="695"
                    colStart="0" colEnd="0" snippet="stunnel.c:695:695"/>
                <Function name="execvp"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="connect_local"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="connect_local"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>357CD03E0BE0C111E45D12A8B7260559</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="0" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="EF4A4B39F6474C1D39358F2EE0F888637D462BFC">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="550" lineEnd="550"
                    colStart="0" colEnd="0" snippet="stunnel.c:550:550"/>
                <Function name="unlink"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
            <Node inArg="1" outArg="0" ruleID="C95F10BD-09EF-4014-9E1A-59B6274A7ACF">
              <SourceRef sourceRefID="C19E1266BAC9C94ACC289854EAA28FF43F940608">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="546" lineEnd="546"
                  colStart="0" colEnd="0" snippet="stunnel.c:546:546"/>
                  <Function name="strncpy"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>9BDF272C67A3712941E2C65CC4DC32D4</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="1" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="EF4A4B39F6474C1D39358F2EE0F888637D462BFC">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="550" lineEnd="550"
                    colStart="0" colEnd="0" snippet="stunnel.c:550:550"/>
                <Function name="unlink"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="1" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
            <Node inArg="1" outArg="0" ruleID="C95F10BD-09EF-4014-9E1A-59B6274A7ACF">
              <SourceRef sourceRefID="C19E1266BAC9C94ACC289854EAA28FF43F940608">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="546" lineEnd="546"
                  colStart="0" colEnd="0" snippet="stunnel.c:546:546"/>
                  <Function name="strncpy"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>F44AF7FE80A652889BEC71F2A49C19E7</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="0" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="4D24F87EB72A467FA5F1135023696E8110D2DF05">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="551" lineEnd="551"
                    colStart="0" colEnd="0" snippet="stunnel.c:551:551"/>
                <Function name="open"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="0" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
            <Node inArg="1" outArg="0" ruleID="C95F10BD-09EF-4014-9E1A-59B6274A7ACF">
              <SourceRef sourceRefID="C19E1266BAC9C94ACC289854EAA28FF43F940608">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="546" lineEnd="546"
                  colStart="0" colEnd="0" snippet="stunnel.c:546:546"/>
                  <Function name="strncpy"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A</ClassID>
        <Type>Resource Injection</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>7D4FF97F8D2EEA4ADCFA25BF111F9B8E</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Dataflow>
          <Source inArg="1" ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
            <SourceRef sourceRefID="F30C431AE9C1D30BD34147A782068FEE5BEFF4CE">
              <FunctionEntry>
                <SourceLocation path="stunnel.c"
                    line="141" lineEnd="141"
                    colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
                <Function name="main"/>
              </FunctionEntry>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Source>
          <Sink inArg="0" ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
            <SourceRef sourceRefID="4D24F87EB72A467FA5F1135023696E8110D2DF05">
              <FunctionCall>
                <SourceLocation path="stunnel.c"
                    line="551" lineEnd="551"
                    colStart="0" colEnd="0" snippet="stunnel.c:551:551"/>
                <Function name="open"/>
              </FunctionCall>
            </SourceRef>
            <Context>
              <Function name="create_pid"/>
            </Context>
          </Sink>
          <Path>
            <Node inArg="1" outArg="{options}">
              <SourceRef sourceRefID="E7D1E4B70D9EA31369237C87C592059CAFB62B44">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="167" lineEnd="167"
                  colStart="0" colEnd="0" snippet="stunnel.c:167:167"/>
                  <Function name="get_options"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
            <Node inArg="1" outArg="0" ruleID="C95F10BD-09EF-4014-9E1A-59B6274A7ACF">
              <SourceRef sourceRefID="C19E1266BAC9C94ACC289854EAA28FF43F940608">
                <FunctionCall>
                  <SourceLocation path="stunnel.c"
                  line="546" lineEnd="546"
                  colStart="0" colEnd="0" snippet="stunnel.c:546:546"/>
                  <Function name="strncpy"/>
                </FunctionCall>
              </SourceRef>
              <Context>
                <Function name="create_pid"/>
              </Context>
            </Node>
          </Path>
          <TaintFlags>
            <TaintFlag name="ARGS"/>
            <TaintFlag name="NULL_TERMINATED"/>
          </TaintFlags>
        </Dataflow>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>3D1141D1-64C3-4BDE-A561-A13D77413507</ClassID>
        <Type>Unreleased Resource</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>FCFF65C7E313A559BCC17500CEF0C5DF</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Stateful primary="0">
          <Transition>
            <FromState>start</FromState>
            <ToState>loaded</ToState>
            <Pattern>fd = open(...)</Pattern>
            <SourceRef>
              <Statement type="assignment">
                <SourceLocation path="pty.c" line="255"
                    lineEnd="255" colStart="0"
                    colEnd="0" snippet="pty.c:255:255"/>
                <Variable name="fd"/>
              </Statement>
            </SourceRef>
          </Transition>
          <Transition>
            <FromState>loaded</FromState>
            <ToState>end_of_scope</ToState>
            <Pattern>#end_scope(fd)</Pattern>
            <SourceLocation path="pty.c" line="268"
                lineEnd="268" colStart="0" colEnd="0" snippet="pty.c:268:268"/>
          </Transition>
        </Stateful>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>3D1141D1-64C3-4BDE-A561-A13D77413507</ClassID>
        <Type>Unreleased Resource</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>E7CD810CAA10F68D09C07D5745512287</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Stateful primary="0">
          <Transition>
            <FromState>start</FromState>
            <ToState>loaded</ToState>
            <Pattern>fd = open(...)</Pattern>
            <SourceRef>
              <Statement type="assignment">
                <SourceLocation path="pty.c" line="240"
                    lineEnd="240" colStart="0"
                    colEnd="0" snippet="pty.c:240:240"/>
                <Variable name="fd"/>
              </Statement>
            </SourceRef>
          </Transition>
          <Transition>
            <FromState>loaded</FromState>
            <ToState>end_of_scope</ToState>
            <Pattern>#end_scope(fd)</Pattern>
            <SourceLocation path="pty.c" line="268"
                lineEnd="268" colStart="0" colEnd="0" snippet="pty.c:268:268"/>
          </Transition>
        </Stateful>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>3D1141D1-64C3-4BDE-A561-A13D77413507</ClassID>
        <Type>Unreleased Resource</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>81C65DF65CFA7ADDE670A671D7505BE3</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Stateful primary="0">
          <Transition>
            <FromState>start</FromState>
            <ToState>loaded</ToState>
            <Pattern>fd = open(...)</Pattern>
            <SourceRef>
              <Statement type="assignment">
                <SourceLocation path="pty.c" line="262"
                    lineEnd="262" colStart="0"
                    colEnd="0" snippet="pty.c:262:262"/>
                <Variable name="fd"/>
              </Statement>
            </SourceRef>
          </Transition>
          <Transition>
            <FromState>loaded</FromState>
            <ToState>end_of_scope</ToState>
            <Pattern>#end_scope(fd)</Pattern>
            <SourceLocation path="pty.c" line="268"
                lineEnd="268" colStart="0" colEnd="0" snippet="pty.c:268:268"/>
          </Transition>
        </Stateful>
      </AnalysisInfo>
    </Vulnerability>
    <Vulnerability>
      <ClassInfo>
        <ClassID>3D1141D1-64C3-4BDE-A561-A13D77413507</ClassID>
        <Type>Unreleased Resource</Type>
        <DefaultSeverity>3.0</DefaultSeverity>
      </ClassInfo>
      <InstanceInfo>
        <InstanceID>E7CD810CAA10F68D09C07D5745512286</InstanceID>
        <InstanceSeverity>3.0</InstanceSeverity>
        <Confidence>5.0</Confidence>
      </InstanceInfo>
      <AnalysisInfo>
        <Stateful primary="0">
          <Transition>
            <FromState>start</FromState>
            <ToState>loaded</ToState>
            <Pattern>fd = open(...)</Pattern>
            <SourceRef>
              <Statement type="assignment">
                <SourceLocation path="pty.c" line="227"
                    lineEnd="227" colStart="0"
                    colEnd="0" snippet="pty.c:227:227"/>
                <Variable name="fd"/>
              </Statement>
            </SourceRef>
          </Transition>
          <Transition>
            <FromState>loaded</FromState>
            <ToState>end_of_scope</ToState>
            <Pattern>#end_scope(fd)</Pattern>
            <SourceLocation path="pty.c" line="268"
                lineEnd="268" colStart="0" colEnd="0" snippet="pty.c:268:268"/>
          </Transition>
        </Stateful>
      </AnalysisInfo>
    </Vulnerability>
  </Vulnerabilities>
  <Description classID="948FF8C7-B5FF-4D31-876B-1F2B7E142F68">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or allow the execution of malicious code.</Abstract>
    <Explanation>
      Background: The buffer overflow is probably the best know security vulnerability in software. Exploits of buffer overflow vulnerabilities have existed for years, but both legacy applications and newly developed code continue to fall victim with alarming regularity. Although nearly every software developer has heard of buffer overflows, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them relegate many of today's developers to repeat the mistakes of the past.

      The canonical exploit of a buffer overflow occurs when an attacker supplies data to a program, which it stores in a stack allocated buffer, overflowing the bounds of the buffer. Rather than arbitrary data, the attacker supplies a segment of malicious code followed by values designed to overwrite the return value of the function and cause it to jump into and begin executing the code stored in the buffer. Although this type of stack buffer overflow is quite common, there are also a variety of other types, such as heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to explain the distinct types of buffer overflows and the variety of specific exploits used against them. If you want to read more on this topic there are a variety of excellent books that provide further discussion. We recommend Building Secure Software [1], Writing Secure Code [2] and Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a variety of ways, but they almost always involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking, and thus can easily exceed the allocated bounds of the buffers they operate on. Even bounded functions, such as &lt;code&gt;n&lt;/code&gt; functions like &lt;code&gt;strncpy()&lt;/code&gt;, can easily cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. In order to clarify this statement we propose that most buffer overflows occur in programs that perform memory operations in code that:

      1. Relies on external data to control any part of its behavior.

      2. Depends on properties of data that are enforced outside of its immediate scope.

      3. Is overly complex to the point where a human can no longer make accurate deductions about its behavior.

      In this case we are primarily concerned with the second case, because we cannot verify the safety of the operation performed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;. (We will also offer examples and comment on scenarios one and three.)

      &lt;b&gt;Example 1:&lt;/b&gt; Below is an implantation of the function &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on the input &lt;code&gt;str&lt;/code&gt;, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow the &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that it does not enforce locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 2.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read (an arbitrary amount) of data into a stack allocated buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 3:&lt;/b&gt; The code in Example 2 also relies on user input to control its behavior, but adds a level of indirection to what we saw in Example 1. Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is also read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Vulnerabilities of this type, where a program reads data and then uses a size value read from an external source to perform an operation on the data have occurred with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;legnth&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or (&lt;code&gt;UNLEN+1)*sizeof(WCHAR)*
      sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info){
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI string functions defined in &lt;code&gt;strsafe.h&lt;/code&gt; [4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not go far enough on its own to ensure security.

      Whenever you manipulate memory, and especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never rely on an external source to control any aspect of a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; make it as simple as possible and clearly document what checks are performed, what assumptions hold or are verified and what the expected behavior is. When data input data is too large, watch out for problems that may result from simply truncating data -- this may not be the right way to handle the error and lead to other issues because the data will likely be malformed.

      Finally, do not rely on tools such as StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools can almost always be defeated and treat the symptoms rather than the cause of buffer overflows -- the software. They are also unable to address the threats of heap buffer overflows and more subtle overflows that simply change the contents variables used to control the program.
    </Recommendations>
  </Description>
  <Description classID="14690628-80D2-4B94-9677-B69C71BF91AF">
    <Abstract>Executing commands that include unvalidated user input may cause an application to act on behalf of an attacker.</Abstract>
    <Explanation>
      Process control vulnerabilities take two forms:

      1. An attacker can change the command that the program executes: the attacker explicitly controls what the command is.

      2. An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.

      In this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Process control vulnerabilities of this type occur when:

      1. Data enters the application from an untrusted source.

      In this case the data enters at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt;.

      2. The data is part of a string that is executed as a command by the application.

      In this case the command is executed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.

      &lt;b&gt;Example 1:&lt;/b&gt; The following simple program accepts a file name as a command line argument and then displays the contents of the file back to the user. The program is installed &lt;code&gt;setuid root&lt;/code&gt; because it is intended for use as a learning tool to allow system administrators in-training to inspect privileged system files without giving them the ability to modify them or do any other damage to the system.

      &lt;pre&gt;
      int main(char* argc, char** argv) {
      char cmd[CMD_MAX] = "/usr/bin/cat ";
      strcat(cmd, argv[1]);
      system(cmd);
      }
      &lt;/pre&gt;

      Because the program runs with &lt;code&gt;root&lt;/code&gt; privileges, the call to &lt;code&gt;system()&lt;/code&gt; is performed with &lt;code&gt;root&lt;/code&gt; privileges as well. If a user specifies a normal filename, the call will work as expected. However, if an attacker passes a string of the form &lt;code&gt;";rm --rf /"&lt;/code&gt;, then the call to &lt;code&gt;system()&lt;/code&gt; will fail to execute &lt;code&gt;cat&lt;/code&gt; due to a lack of arguments and then recursively delete all of the contents of the root partition.

      &lt;b&gt;Example 2:&lt;/b&gt; The following code from a privileged program is meant to use the environment variable &lt;code&gt;$APPHOME&lt;/code&gt; to determine the application install directory and then execute an initialization script found under that directory.

      &lt;pre&gt;
      ...
      char* home=getenv("APPHOME");
      char* cmd=(char*)malloc(strlen(home)+strlen(INITCMD));
      if (cmd) {
      strcpy(cmd,home);
      strcat(cmd,INITCMD);
      execl(cmd, NULL);
      }
      ...
      &lt;/pre&gt;

      Similar to Example 1, the code in Example 2 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the environment variable &lt;code&gt;$APPHOME&lt;/code&gt; to point to a different path containing a malicious version of &lt;code&gt;INITCMD&lt;/code&gt;. Because the program does not validate the value read from the environment, if an attacker can control the environment variable, then they can fool the application into running malicious code.

      Although the attack vector in the previous example is an environment variable, the attacker is using the environment variable to control the command that the program invokes, so the effect of the environment explicit when you look at the program. We will now turn our attention to what can happen when the attacker can change the way the command is interpreted.

      &lt;b&gt;Example 3:&lt;/b&gt; The following code is from a web-based CGI utility that gives users the ability to change their passwords. Part of the process for updating passwords under NIS is to run &lt;code&gt;make&lt;/code&gt; in the &lt;code&gt;/var/yp&lt;/code&gt; directory. The program invokes &lt;code&gt;make&lt;/code&gt; like this:

      &lt;pre&gt;
      system("cd /var/yp &amp;&amp; make &amp;&gt; /dev/null");
      &lt;/pre&gt;

      Unlike the previous examples, the command in this example is hardcoded, so there is no simple way for the attacker to control the argument passed to &lt;code&gt;system()&lt;/code&gt;. However, the program does not specify an absolute path for &lt;code&gt;make&lt;/code&gt; and fails to scrub its environment variables prior to invoking the command. Any unscrupulous user on the system can modify their &lt;code&gt;$PATH&lt;/code&gt; variable to point to a malicious binary named &lt;code&gt;make&lt;/code&gt; and then execute the CGI script from a shell prompt. Because the program is meant to update password records, it is installed &lt;code&gt;setuid root&lt;/code&gt;, so the attacker's version of &lt;code&gt;make&lt;/code&gt; will now be run with &lt;code&gt;root&lt;/code&gt; privileges.

      The environment plays a powerful role in the execution of system commands within programs. Functions like &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; use the environment of the program that calls them, which can all too often be influenced by the user.
    </Explanation>
    <Recommendations>
      Do not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all.

      In cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will be heavily dependant on the system where the commands are executed. A better approach is to create a white list of characters that are allowed to appear in the input and accept input composed exclusively of characters in the approved set.

      Another line of defense against maliciously crafted input is to avoid the use of functions that perform shell interpretation. Do no use functions like &lt;code&gt;system()&lt;/code&gt; that execute in a shell.

      Next, be aware of the external environment and how it affects the behavior of the commands you execute. Pay particular attention to $PATH, $LD_LIBRARY_PATH, and $IFS on *nix machines, and keep in mind that Windows APIs impose a specific search order based not only on a series of directories, but also on a list of file extensions that are automatically appended if none is specified.

      In the end it may be impossible for a program to fully protect itself from an imaginative attacker bent on controlling the commands it executes. Be sure that you have applied the principle of least privilege wherever the program executes an external command--do not hold privileges that are not essential to the execution of the command.
    </Recommendations>
  </Description>
  <Description classID="3D1141D1-64C3-4BDE-A561-A13D77413507">
    <Abstract>The program can potentially fail to release a system resource.</Abstract>
    <Explanation>
      The program can potentially fail to release a system resource. In this case, there are program paths on which the resource allocated in &lt;srcfile&gt; at line &lt;srcline&gt; is not always released.

      Resource leaks have at least two common causes:

      1. Error conditions and other exceptional circumstances.

      2. Confusion over which part of the program is responsible for releasing the resource.

      Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, he may be able to deny service to other users by depleting the resource pool.

      &lt;b&gt;Example 1:&lt;/b&gt; The following function does not close the file handle it opens if an error occurs. If the process is long-lived, the process may run out of file handles.

      &lt;pre&gt;
      int decodeFile(char* fName)
      {
      char buf[BUF_SZ];
      FILE* f = fopen(fName, "r");

      if (!f) {
      printf("cannot open %s\n", fName);
      return DECODE_FAIL;
      } else {
      while (fgets(buf, BUF_SZ, f)) {
      if (!checkChecksum(buf)) {
      return DECODE_FAIL;
      } else {
      decodeBlock(buf);
      }
      }
      }
      fclose(f);
      return DECODE_SUCCESS;
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Because resource leaks can be hard to track down, it pays to establish a set of resource management patterns and idioms for your software. Do not tolerate deviations from the conventions you establish.

      One good pattern for addressing the resource management mistake given in the example above is to use forward-reaching &lt;code&gt;goto&lt;/code&gt; statements so that the function has a single well-defined region for handling errors, as follows:

      &lt;pre&gt;
      int decodeFile(char* fName)
      {
      char buf[BUF_SZ];
      FILE* f = fopen(fName, "r");

      if (!f) {
      goto ERR;
      } else {
      while (fgets(buf, BUF_SZ, f)) {
      if (!checkChecksum(buf)) {
      goto ERR;
      } else {
      decodeBlock(buf);
      }
      }
      }
      fclose(f);
      return DECODE_SUCCESS;

      ERR:
      if (!f) {
      printf("cannot open %s\n", fName);
      } else {
      fclose(f);
      }
      return DECODE_FAIL;
      }
      &lt;/pre&gt;
    </Recommendations>
  </Description>
  <Description classID="34144386-FFE3-4848-B516-79131B80AD88">
    <Abstract>Failure to adhere to the principle of least privilege amplifies the risk posed by other vulnerabilities.</Abstract>
    <Explanation>
      Programs that run with &lt;code&gt;root&lt;/code&gt; privileges are at the heart of too many Unix security disasters to name. It is imperative that privileged programs be carefully reviewed for security problems of all kinds, but it is equally important that privileged programs drop back to an unprivileged state as quickly as possible in order to limit the amount of damage that an overlooked vulnerability might be able to cause.

      In this case, the privilege management function being called is &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-&lt;code&gt;root&lt;/code&gt; user to another.

      Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as &lt;code&gt;root&lt;/code&gt; when a signal fires or a sub-process is executed, the signal handler or sub-process will be operating with root privileges. An attacker may be able to leverage the elevated privileges to do further damage.
    </Explanation>
    <Recommendations>
      If a program can be rewritten so that it does not need root access, rewrite it.

      Disable signals before elevating privileges in order to avoid having signal handling code run with unexpected privileges. Re-enable signals after dropping back to user privilege.

      Whenever possible, drop privileges by calling &lt;code&gt;setuid()&lt;/code&gt; with a non-zero argument immediately after performing the necessary privileged operations.

      In some situations it may be impossible for an application to make use of the &lt;code&gt;setuid()&lt;/code&gt;/&lt;code&gt;setgid()&lt;/code&gt; calls to drop privileges. This usually occurs when the application needs the ongoing ability to perform some operation as &lt;code&gt;root&lt;/code&gt; on behalf of the user. For example, an FTP daemon needs to bind to a port between 1 and 1024 in order to service user requests. In such cases, &lt;code&gt;seteuid()&lt;/code&gt; and &lt;code&gt;getegid()&lt;/code&gt; should be used to temporarily drop to a lower effective privilege level while retaining the ability to return to &lt;code&gt;root&lt;/code&gt; privileges when necessary. Keep in mind, it may be equally easy for an attacker to return the application to &lt;code&gt;root&lt;/code&gt; privileges as well, so only use &lt;code&gt;seteuid()&lt;/code&gt;/&lt;code&gt;getegid()&lt;/code&gt;when there is no way to drop privileges entirely.

      The following program gives a general outline of a well-constructed setuid root program:

      &lt;pre&gt;
      int main(int argc, char** argv) {
      uid_t runner_uid = getuid();
      uid_t runner_gid = getgid();
      uid_t owner_uid = geteuid();
      uid_t owner_gid = getegid();
      int sigmask;

      /* Drop privileges right up front, but
      we'll need them back in a little bit,
      so use effective id */
      if (setreuid(owner_uid, runner_uid) ||
      setregid(owner_gid, runner_gid)) {
      exit(-1);
      }

      /* privilege not necessary or desirable at this point */
      processCommandLine(argc, argv);

      /* disable signal handling */
      sigmask = sigprocmask(~0);

      /* Take privileges back */
      if (setreuid(runner_uid, owner_uid) ||
      setregid(runner_gid, owner_gid)) {
      exit(-1);
      }

      openSocket(88);  /* requires root */

      /* Drop privileges for good */
      if (setuid(runner_uid) || setgid(runner_gid)) {
      exit(-1);
      }

      /* re-enable signals */
      sigprocmask(sigmask);

      doWork();
      }
      &lt;/pre&gt;

      Another approach to retaining some privileges while minimizing risk is to partition the program into privileged and unprivileged pieces. Create two processes, one that does the majority of the work and runs without privileges, and a second that retains privileges but only carries out a very limited number of operations at the request of the other process.

      Chen and Wagner offer up wrapper functions in order to provide a more consistant and easy to understand interface for privilege management.
    </Recommendations>
    <Tips>
      <Tip>Review the code surrounding this call. Determine the extent of the code that will be executed with elevated privileges. Which operations absolutely require elevated privileges?  Is there a way to reduce the amount of code in the privileged section?</Tip>
      <Tip>Be sure that the program checks the return value of any privilege management functions it invokes. If attackers find a way to block a privilege transition from taking place, they may be able to take advantage the fact that the program is executing under unexpected conditions.</Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Setuid Demystified.</Title>
        <Author>H. Chen, D. Wagner, and D. Dean.</Author>
        <Publisher>11th USENIX  Security Symposium</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="256FF15F-1828-4657-9E4C-9D606DABBEAA">
    <Abstract>Attackers can spoof DNS entries. Do not rely on DNS names for security.</Abstract>
    <Explanation>
      Many DNS servers are susceptible to spoofing attacks, so you should assume that your software will someday run in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (i.e. perform DNS cache poisoning), they can route your network traffic through their machines or make it appear that their IP addresses are part of your domain. Do not base the security of your system on DNS names.

      In this case, DNS information enters the program at &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; The following code sample uses a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.

      &lt;pre&gt;
      struct hostent *hp;
      struct in_addr myaddr;
      char* tHost = "trustme.trusty.com";
      myaddr.s_addr=inet_addr(ip_addr_string);

      hp = gethostbyaddr((char *) &amp;myaddr,
      sizeof(struct in_addr), AF_INET);
      if (hp &amp;&amp; !strncmp(hp-&gt;h_name, tHost, sizeof(tHost))) {
      trusted = true;
      } else {
      trusted = false;
      }
      &lt;/pre&gt;

      IP addresses are substantially more reliable than DNS names, but they can also be spoofed. Attackers can forge the source IP address of the packets they send without too much trouble, but any response packets will head back to the forged IP address. In order to see any of the response packets, the attacker needs to be able to be able to sniff the traffic between the victim machine and the forged IP address. The most common way to do this is for the attacker to be located on the same subnet as the victim machine. IP address verification can be a useful part of an authentication scheme, but it should not be used as the single factor required for authentication.
    </Explanation>
    <Recommendations>While no authentication mechanism is foolproof, there are better alternatives than host-based authentication. A password approach has the potential to offer decent security, but password systems are often suffer from bad password choices, insecure password transmission, and bad password management. A cryptographic scheme is worth considering, but key material can be stolen. In many situations, multi-factor authentication including a physical token offers the most security available at a reasonable price.</Recommendations>
    <Tips>
      <Tip>Check how the DNS information is being used. In addition to considering whether or not the program's authentication mechanisms might be defeated, think about how DNS spoofing might be used as part of a social engineering attack. For example, if attackers could make it appear that a posting came from an internal machine, could they gain credibility?</Tip>
    </Tips>
  </Description>
  <Description classID="20FF3BA7-0457-463A-A96F-25BC7457EC0C">
    <Abstract>Ignoring a method's return value may cause the program to overlook unexpected states and conditions.</Abstract>
    <Explanation>
      Just about every good attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

      Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". These assumptions are represented by the failure to check the return value from a library function.

      In this case, the value of &lt;sinkfunc&gt; is unchecked in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; Consider the following three lines of code:

      &lt;pre&gt;
      char buf[10], cp_buf[10];
      fgets(buf, 10, stdin);
      strcpy(cp_buf, buf);
      &lt;/pre&gt;

      The programmer expects that when &lt;code&gt;fgets()&lt;/code&gt; returns, &lt;code&gt;buf&lt;/code&gt; will contain a null-terminated string of length 9 or less. But if an I/O error occurs, &lt;code&gt;fgets()&lt;/code&gt; will not null-terminate &lt;code&gt;buf&lt;/code&gt;. Further, if the end-of-file is reached before any characters are read, &lt;code&gt;fgets()&lt;/code&gt; will return without writing anything at all to &lt;code&gt;buf&lt;/code&gt;. In both of these situations &lt;code&gt;fgets()&lt;/code&gt; will signal that something out of the ordinary has happened by returning &lt;code&gt;NULL&lt;/code&gt;, but in this code the warning will go unnoticed. The lack of a null terminator in &lt;code&gt;buf&lt;/code&gt; could easily result in a buffer overflow in the subsequent call to &lt;code&gt;strcpy()&lt;/code&gt;.

      &lt;b&gt;Example 2:&lt;/b&gt;  In the following code, the programmer does not check whether or not memory allocation succeeded before using the memory.

      &lt;pre&gt;
      buf = (char*) malloc(req_size);
      strncpy(buf, xfer, req_size);
      &lt;/pre&gt;

      The traditional defense of this coding error is as follows:

      "If my program runs out of memory, it is doomed to failure. It doesn't matter whether I handle the error or simply seg fault trying to dereference a null pointer".

      This argument ignores three important considerations. First, depending on the type and size of the application, it may be possible to free memory being used elsewhere so that execution may continue. Second, it makes it impossible for the program to perform a graceful exit,(if in fact it is necessary to exit at all). If the program is in the middle of what should be an atomic operation, it may leave the system in an inconsistent state. Third, the programmer has passed up any opportunity to record diagnostic information. Did the call to &lt;code&gt;malloc()&lt;/code&gt; fail because &lt;code&gt;req_size&lt;/code&gt; was enormous, because there were too many requests being handled at the same time, or because of a memory leak that has built up over time?  Without handling the error, there is no way to know.
    </Explanation>
    <Recommendations>
      If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed system call with an ignored return value.

      Create an easy to use and standard way for dealing with failure in your software. If error handling is straightforward, programmers will be less inclined to omit it. One approach standardized error handling is to write wrappers around commonly used functions that check and handle error conditions without additional programmer intervention. If wrappers are implemented and adopted, then the use of non-wrapped equivalents can be prohibited and enforced using custom rules.
    </Recommendations>
    <Tips>
      <Tip>Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...".  Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition may not apply.</Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Building Secure Software</Title>
        <Author>J. Viega, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="37800F72-E40D-49B6-948D-CCA743075F85">
    <Abstract>Allowing an attacker to control a function's format string may result in a buffer overflow.</Abstract>
    <Explanation>
      Format string vulnerabilities occur when an attacker is allowed to control the format string argument to a function like &lt;code&gt;sprintf()&lt;/code&gt;, &lt;code&gt;FormatMessageW()&lt;/code&gt;, or &lt;code&gt;syslog()&lt;/code&gt;.

      In this case the format string for the function &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt; is not constant.

      &lt;b&gt;Example 1:&lt;/b&gt; The following code copies a command line argument into a buffer using &lt;code&gt;snprintf()&lt;/code&gt;.

      &lt;pre&gt;
      int main(int argc, char **argv){
      char buf[128];
      ...
      snprintf(buf,128,argv[1]);
      }
      &lt;/pre&gt;

      The code in Example 1 will allow an attacker to view the contents of the stack and write to the stack by providing a command line argument that has a carefully crafted sequence of formatting directives. Reading from the stack is simply a matter of providing more formatting directives, such as &lt;code&gt;%x&lt;/code&gt;, than the function takes as arguments to be formatted. (In this example, the function takes no arguments to be formatted.)  Writing to the stack can be accomplished using the &lt;code&gt;%n&lt;/code&gt; formatting directive, which causes &lt;code&gt;snprintf()&lt;/code&gt; to write the number of bytes output thus far to the specified argument rather than reading a value from the argument as is usually the case. A sophisticated version of this attack will use four staggered writes to completely control the value of a pointer on the stack.

      Example 2: Certain implementations make more advanced attacks even easier by providing format directives to control the location in memory to read from or write to. An example of these directives is shown in the following code written for glibc:

      &lt;pre&gt;
      printf("%d %d %1$d %1$d\n", 5, 9);
      &lt;/pre&gt;

      This code will produce the following output:

      &lt;pre&gt;
      5 9 5 5
      &lt;/pre&gt;

      It is also possible to use half-writes (%hn) to accurately control arbitrary DWORDS in memory, which greatly reduces the complexity needed to execute an attack that would otherwise require four staggered writes, such as the one described in Example 1.

      Example 3: The simplest format string vulnerabilities are the result of what the programmer might believe to be an innocuous shortcut. At times, these shortcuts become so ingrained that developers are no longer cognizant that the function they are using expects a format string argument. The &lt;code&gt;syslog()&lt;/code&gt; function is sometimes used in the following way:

      &lt;pre&gt;
      ...
      syslog(LOG_ERR, cmdBuf);
      ...
      &lt;/pre&gt;

      However, the second parameter to &lt;code&gt;syslog()&lt;/code&gt; is a format string, so any formatting directives included in cmdBuf will be interpreted as we saw in Example 1. The simplest correct use of &lt;code&gt;syslog()&lt;/code&gt; is this instance would be:

      &lt;pre&gt;
      ...
      syslog(LOG_ERR, "%s", cmdBuf);
      ...
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>Whenever possible, pass static format string to functions that accept a format string argument. If format strings must be constructed dynamically, define a set of valid format strings and make selections from this safe set. Finally, always verify that the number of formatting directives in the selected format string corresponds with the number of arguments passed to the function to be formatted.</Recommendations>
    <References>
      <Reference>
        <Title>Format String Attacks</Title>
        <Author>T. Newsham</Author>
        <Publisher>Guardent, Inc.</Publisher>
        <PublishedDate>2000</PublishedDate>
        <Source></Source>
      </Reference>
    </References>
  </Description>
  <Description classID="57635DC2-A681-4A15-8A66-59364C65D332">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or allow the execution of malicious code.</Abstract>
    <Explanation>
      Background: The buffer overflow is probably the best know security vulnerability in software. Exploits of buffer overflow vulnerabilities have existed for years, but both legacy applications and newly developed code continue to fall victim with alarming regularity. Although nearly every software developer has heard of buffer overflows, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them relegate many of today's developers to repeat the mistakes of the past.

      The canonical exploit of a buffer overflow occurs when an attacker supplies data to a program, which it stores in a stack allocated buffer, overflowing the bounds of the buffer. Rather than arbitrary data, the attacker supplies a segment of malicious code followed by values designed to overwrite the return value of the function and cause it to jump into and begin executing the code stored in the buffer. Although this type of stack buffer overflow is quite common, there are also a variety of other types, such as heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to explain the distinct types of buffer overflows and the variety of specific exploits used against them. If you want to read more on this topic there are a variety of excellent books that provide further discussion. We recommend Building Secure Software [1], Writing Secure Code [2] and Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a variety of ways, but they almost always involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking, and thus can easily exceed the allocated bounds of the buffers they operate on. Even bounded functions, such as &lt;code&gt;n&lt;/code&gt; functions like &lt;code&gt;strncpy()&lt;/code&gt;, can easily cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. In order to clarify this statement we propose that most buffer overflows occur in programs that perform memory operations in code that:

      1. Relies on external data to control any part of its behavior.

      2. Depends on properties of data that are enforced outside of its immediate scope.

      3. Is overly complex to the point where a human can no longer make accurate deductions about its behavior.

      In this case we are primarily concerned with the second case, because we cannot verify the safety of the operation performed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;. (We will also offer examples and comment on scenarios one and three.)

      &lt;b&gt;Example 1:&lt;/b&gt; Below is an implantation of the function &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on the input &lt;code&gt;str&lt;/code&gt;, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow the &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that it does not enforce locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 2.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read (an arbitrary amount) of data into a stack allocated buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 3:&lt;/b&gt; The code in Example 2 also relies on user input to control its behavior, but adds a level of indirection to what we saw in Example 1. Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is also read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Vulnerabilities of this type, where a program reads data and then uses a size value read from an external source to perform an operation on the data have occurred with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;legnth&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or (&lt;code&gt;UNLEN+1)*sizeof(WCHAR)*
      sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info){
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI string functions defined in &lt;code&gt;strsafe.h&lt;/code&gt; [4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not go far enough on its own to ensure security.

      Whenever you manipulate memory, and especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never rely on an external source to control any aspect of a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; make it as simple as possible and clearly document what checks are performed, what assumptions hold or are verified and what the expected behavior is. When data input data is too large, watch out for problems that may result from simply truncating data -- this may not be the right way to handle the error and lead to other issues because the data will likely be malformed.

      Finally, do not rely on tools such as StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools can almost always be defeated and treat the symptoms rather than the cause of buffer overflows -- the software. They are also unable to address the threats of heap buffer overflows and more subtle overflows that simply change the contents variables used to control the program.
    </Recommendations>
  </Description>
  <Description classID="7D8CF10B-0535-4B3B-B899-F7885493EF39">
    <Abstract>Ignoring a method's return value may cause the program to overlook unexpected states and conditions.</Abstract>
    <Explanation>
      Just about every good attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

      Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". These assumptions are represented by the failure to check the return value from a library function.

      In this case, the value of &lt;sinkfunc&gt; is unchecked in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; Consider the following three lines of code:

      &lt;pre&gt;
      char buf[10], cp_buf[10];
      fgets(buf, 10, stdin);
      strcpy(cp_buf, buf);
      &lt;/pre&gt;

      The programmer expects that when &lt;code&gt;fgets()&lt;/code&gt; returns, &lt;code&gt;buf&lt;/code&gt; will contain a null-terminated string of length 9 or less. But if an I/O error occurs, &lt;code&gt;fgets()&lt;/code&gt; will not null-terminate &lt;code&gt;buf&lt;/code&gt;. Further, if the end-of-file is reached before any characters are read, &lt;code&gt;fgets()&lt;/code&gt; will return without writing anything at all to &lt;code&gt;buf&lt;/code&gt;. In both of these situations &lt;code&gt;fgets()&lt;/code&gt; will signal that something out of the ordinary has happened by returning &lt;code&gt;NULL&lt;/code&gt;, but in this code the warning will go unnoticed. The lack of a null terminator in &lt;code&gt;buf&lt;/code&gt; could easily result in a buffer overflow in the subsequent call to &lt;code&gt;strcpy()&lt;/code&gt;.

      &lt;b&gt;Example 2:&lt;/b&gt;  In the following code, the programmer does not check whether or not memory allocation succeeded before using the memory.

      &lt;pre&gt;
      buf = (char*) malloc(req_size);
      strncpy(buf, xfer, req_size);
      &lt;/pre&gt;

      The traditional defense of this coding error is as follows:

      "If my program runs out of memory, it is doomed to failure. It doesn't matter whether I handle the error or simply seg fault trying to dereference a null pointer".

      This argument ignores three important considerations. First, depending on the type and size of the application, it may be possible to free memory being used elsewhere so that execution may continue. Second, it makes it impossible for the program to perform a graceful exit,(if in fact it is necessary to exit at all). If the program is in the middle of what should be an atomic operation, it may leave the system in an inconsistent state. Third, the programmer has passed up any opportunity to record diagnostic information. Did the call to &lt;code&gt;malloc()&lt;/code&gt; fail because &lt;code&gt;req_size&lt;/code&gt; was enormous, because there were too many requests being handled at the same time, or because of a memory leak that has built up over time?  Without handling the error, there is no way to know.
    </Explanation>
    <Recommendations>
      If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed system call with an ignored return value.

      Create an easy to use and standard way for dealing with failure in your software. If error handling is straightforward, programmers will be less inclined to omit it. One approach standardized error handling is to write wrappers around commonly used functions that check and handle error conditions without additional programmer intervention. If wrappers are implemented and adopted, then the use of non-wrapped equivalents can be prohibited and enforced using custom rules.
    </Recommendations>
    <Tips>
      <Tip>Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...".  Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition may not apply.</Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Building Secure Software</Title>
        <Author>J. Viega, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
    <Abstract>Allowing an attacker to specify resource identifiers may enable the attacker to access or modify otherwise protected system resources.</Abstract>
    <Explanation>
      A resource injection issue occurs when the following two conditions are met:

      1. An attacker is allowed to specify the identifier used to access a system resource. For example, an attacker might be able to specify part of the name of a file to be opened or a port number to be used.

      2. By specifying the resource, the attacker gains a capability he would not otherwise have. For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.

      In this case, the attacker can specify the value that enters the program at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt;, and this value is used to access a system resource at &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; The following code uses input from a CGI request to create a file name. The author has not considered the possibility that an attacker may provide a file name like "&lt;code&gt;../../apache/conf/httpd.conf&lt;/code&gt;", which will cause the application to delete the specified configuration file.

      &lt;pre&gt;
      char* rName = getenv("reportName");
      ...
      unlink (fName);
      &lt;/pre&gt;

      &lt;b&gt;Example 2:&lt;/b&gt; The following code uses input from the command line to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can create soft links to the file, they can use the program to read the first portion of any file on the system.

      &lt;pre&gt;
      ifstream ifs(argv[0]);
      string s;
      ifs &gt;&gt; s;
      cout &lt;&lt; s;
      &lt;/pre&gt;

      The kind of resource the data affects indicates the kind of content that may be dangerous. For example, input that is allowed to contain filesystem special characters like period, slash, and backslash warrants attention when it can reach methods that interact with the file system; similarly, data that may hold URLs and URIs are a risk for functions used to create remote connections. One special case of resource injection, known as Path Manipulation, occurs when an attacker is able to control filesystem resources on a Web server.
    </Explanation>
    <Recommendations>
      The best way to prevent resource injection is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name.

      In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.
    </Recommendations>
    <Tips>
      <Tip>
        If the program is performing input validation, you should satisfy yourself that the validation is correct, then use Fortify Rules Builder to create a cleanse rule for the validation routine.

        It is notoriously difficult to correctly implement a blacklist. If the validation logic relies on blacklisting, be skeptical. Consider different types of input encoding and different sets of metacharacters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the program is designed in such a way that the blacklist can be updated easily, correctly, and completely if these requirements ever change.
      </Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Exploiting Software</Title>
        <Author>G. Hoglund, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2004</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="28424EC3-FFAC-40C0-94D9-3D8283B2F57C">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or cause the execution of malicious code.</Abstract>
    <Explanation>
      &lt;b&gt;Background:&lt;/b&gt; Buffer overflow is probably the best known software security vulnerability. Buffer overflow exploits have existed for years, but both legacy applications and newly developed code continue to fall victim with great regularity. Although almost every software developer has some sense of what a buffer overflow is, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them lead many of today's developers to repeat the mistakes of the past.

      In the canonical buffer overflow exploit, an attacker supplies an unexpectedly large amount of data to a program, and the program stores the data into an undersized stack buffer. Because the attacker's data is too big for the buffer, the data overwrites other information on the call stack including the function's return pointer. The attacker has specially chosen the value that the function pointer is overwritten with, so when the function returns, control jumps to the malicious code that the attacker has cleverly sent along as part of the data.

      Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are also a variety of other buffer overflow types, including heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to make distinctions between types of buffer overflows and the variety of specific exploit techniques used to take advantage of them. There are a number of excellent books that provide detailed information on how buffer overflow attacks work. We recommend Building Secure Software [1], Writing Secure Code [2] and The Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a great variety of ways, but they almost always involve the violation of a programmer's assumptions. Most of the older memory manipulation functions in C and C++ do not perform bounds checking and can easily overwrite the allocated bounds of the buffers they operate upon. Even newer bounded functions like &lt;code&gt;strncpy()&lt;/code&gt; can cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. We propose that most buffer overflows occur in code that:

      1. Relies on external data to control its behavior,

      2. Depends on properties of the data that are enforced outside of the immediate scope of the code, and

      3. Is complex to the point where the programmer cannot make accurate deductions about its behavior.

      In this instance we are primarily concerned with the first case because:

      - External data enters the program at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt;

      &lt;b&gt;AND&lt;/b&gt;

      -	The data affects the manipulation of memory in &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      (We will offer examples and comment on the second and third conditions later in this description.)

      &lt;b&gt;Example 1.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read an arbitrary amount of data into a stack buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 1.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2:&lt;/b&gt; The code in this example also relies on user input to control its behavior, but it adds a level of indirection . Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer, and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Buffer overflows of this type, where a program reads data and then trusts a value from the data to perform memory operations on the remaining data have cropped up with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 3:&lt;/b&gt; Below is the implantation of a function named &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on its input, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that are not enforced locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;length&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, and if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or
      &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info) {
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI functions defined in &lt;code&gt;strsafe.h &lt;/code&gt;[4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not solve the buffer overflow problem.

      Whenever you manipulate memory, especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never trust an external source to provide correct control information to be used in a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; go out of your way to make it simple and clearly document the checks you perform, the assumptions that you verify, and what the expected behavior is in the case that input validation fails. When input data is too large, watch out for problems that may result from simply truncating the data--truncation may change the meaning of the input.

      Finally, do not rely on tools like StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools are unable to address heap buffer overflows and more subtle stack overflows that simply change the contents variables used to control the program. Additionally, these tools can almost always be defeated, and even when they are working properly they treat the symptoms rather than the causes of buffer overflow.
    </Recommendations>
    <References>
      <Reference>
        <Title>Building Secure Software</Title>
        <Author>J. Viega, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
      <Reference>
        <Title>Writing Secure Code, Second Edition</Title>
        <Author>M. Howard, D. LeBlanc</Author>
        <Publisher>Microsoft Press</Publisher>
        <PublishedDate>2003</PublishedDate>
      </Reference>
      <Reference>
        <Title>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</Title>
        <Author>J. Koziol et al.</Author>
        <Publisher>John Wiley &amp; Sons</Publisher>
        <PublishedDate>2004</PublishedDate>
      </Reference>
      <Reference>
        <Title>Strsafe.h Functions</Title>
        <Publisher>Microsoft</Publisher>
        <Source>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/resources/strings/usingstrsafefunctions.asp</Source>
      </Reference>
    </References>
  </Description>
  <Description classID="2ABE24EC-297C-4AC3-B441-197D75177A55">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or allow the execution of malicious code.</Abstract>
    <Explanation>
      Background: The buffer overflow is probably the best know security vulnerability in software. Exploits of buffer overflow vulnerabilities have existed for years, but both legacy applications and newly developed code continue to fall victim with alarming regularity. Although nearly every software developer has heard of buffer overflows, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them relegate many of today's developers to repeat the mistakes of the past.

      The canonical exploit of a buffer overflow occurs when an attacker supplies data to a program, which it stores in a stack allocated buffer, overflowing the bounds of the buffer. Rather than arbitrary data, the attacker supplies a segment of malicious code followed by values designed to overwrite the return value of the function and cause it to jump into and begin executing the code stored in the buffer. Although this type of stack buffer overflow is quite common, there are also a variety of other types, such as heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to explain the distinct types of buffer overflows and the variety of specific exploits used against them. If you want to read more on this topic there are a variety of excellent books that provide further discussion. We recommend Building Secure Software [1], Writing Secure Code [2] and Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a variety of ways, but they almost always involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking, and thus can easily exceed the allocated bounds of the buffers they operate on. Even bounded functions, such as &lt;code&gt;n&lt;/code&gt; functions like &lt;code&gt;strncpy()&lt;/code&gt;, can easily cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. In order to clarify this statement we propose that most buffer overflows occur in programs that perform memory operations in code that:

      1. Relies on external data to control any part of its behavior.

      2. Depends on properties of data that are enforced outside of its immediate scope.

      3. Is overly complex to the point where a human can no longer make accurate deductions about its behavior.

      In this case we are primarily concerned with the second case, because we cannot verify the safety of the operation performed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;. (We will also offer examples and comment on scenarios one and three.)

      &lt;b&gt;Example 1:&lt;/b&gt; Below is an implantation of the function &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on the input &lt;code&gt;str&lt;/code&gt;, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow the &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that it does not enforce locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 2.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read (an arbitrary amount) of data into a stack allocated buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 3:&lt;/b&gt; The code in Example 2 also relies on user input to control its behavior, but adds a level of indirection to what we saw in Example 1. Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is also read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Vulnerabilities of this type, where a program reads data and then uses a size value read from an external source to perform an operation on the data have occurred with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;legnth&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or (&lt;code&gt;UNLEN+1)*sizeof(WCHAR)*
      sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info){
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI string functions defined in &lt;code&gt;strsafe.h&lt;/code&gt; [4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not go far enough on its own to ensure security.

      Whenever you manipulate memory, and especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never rely on an external source to control any aspect of a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; make it as simple as possible and clearly document what checks are performed, what assumptions hold or are verified and what the expected behavior is. When data input data is too large, watch out for problems that may result from simply truncating data -- this may not be the right way to handle the error and lead to other issues because the data will likely be malformed.

      Finally, do not rely on tools such as StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools can almost always be defeated and treat the symptoms rather than the cause of buffer overflows -- the software. They are also unable to address the threats of heap buffer overflows and more subtle overflows that simply change the contents variables used to control the program.
    </Recommendations>
  </Description>
  <Description classID="2CB8A870-C25A-4E25-AE37-15D864655F64">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or allow the execution of malicious code.</Abstract>
    <Explanation>
      Background: The buffer overflow is probably the best know security vulnerability in software. Exploits of buffer overflow vulnerabilities have existed for years, but both legacy applications and newly developed code continue to fall victim with alarming regularity. Although nearly every software developer has heard of buffer overflows, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them relegate many of today's developers to repeat the mistakes of the past.

      The canonical exploit of a buffer overflow occurs when an attacker supplies data to a program, which it stores in a stack allocated buffer, overflowing the bounds of the buffer. Rather than arbitrary data, the attacker supplies a segment of malicious code followed by values designed to overwrite the return value of the function and cause it to jump into and begin executing the code stored in the buffer. Although this type of stack buffer overflow is quite common, there are also a variety of other types, such as heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to explain the distinct types of buffer overflows and the variety of specific exploits used against them. If you want to read more on this topic there are a variety of excellent books that provide further discussion. We recommend Building Secure Software [1], Writing Secure Code [2] and Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a variety of ways, but they almost always involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking, and thus can easily exceed the allocated bounds of the buffers they operate on. Even bounded functions, such as &lt;code&gt;n&lt;/code&gt; functions like &lt;code&gt;strncpy()&lt;/code&gt;, can easily cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. In order to clarify this statement we propose that most buffer overflows occur in programs that perform memory operations in code that:

      1. Relies on external data to control any part of its behavior.

      2. Depends on properties of data that are enforced outside of its immediate scope.

      3. Is overly complex to the point where a human can no longer make accurate deductions about its behavior.

      In this case we are primarily concerned with the second case, because we cannot verify the safety of the operation performed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;. (We will also offer examples and comment on scenarios one and three.)

      &lt;b&gt;Example 1:&lt;/b&gt; Below is an implantation of the function &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on the input &lt;code&gt;str&lt;/code&gt;, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow the &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that it does not enforce locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 2.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read (an arbitrary amount) of data into a stack allocated buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 3:&lt;/b&gt; The code in Example 2 also relies on user input to control its behavior, but adds a level of indirection to what we saw in Example 1. Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is also read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Vulnerabilities of this type, where a program reads data and then uses a size value read from an external source to perform an operation on the data have occurred with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;legnth&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or (&lt;code&gt;UNLEN+1)*sizeof(WCHAR)*
      sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info){
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI string functions defined in &lt;code&gt;strsafe.h&lt;/code&gt; [4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not go far enough on its own to ensure security.

      Whenever you manipulate memory, and especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never rely on an external source to control any aspect of a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; make it as simple as possible and clearly document what checks are performed, what assumptions hold or are verified and what the expected behavior is. When data input data is too large, watch out for problems that may result from simply truncating data -- this may not be the right way to handle the error and lead to other issues because the data will likely be malformed.

      Finally, do not rely on tools such as StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools can almost always be defeated and treat the symptoms rather than the cause of buffer overflows -- the software. They are also unable to address the threats of heap buffer overflows and more subtle overflows that simply change the contents variables used to control the program.
    </Recommendations>
  </Description>
  <Description classID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
    <Abstract>Relying on proper string termination may result in a buffer overflow.</Abstract>
    <Explanation>
      String termination errors occur when:

      1. Data enters a program via a function that does not null terminate its output.

      In this case the data enters at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt;.

      2. The data is passed to a function that requires its input to be null terminated.

      In this case the data is passed to &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; The following code reads a buffer from &lt;code&gt;cfgfile&lt;/code&gt; and copies it into &lt;code&gt;inputbuf&lt;/code&gt; using &lt;code&gt;strcpy()&lt;/code&gt;; mistakenly assuming that &lt;code&gt;inputbuf&lt;/code&gt; will contain a &lt;code&gt;NULL&lt;/code&gt; terminator.

      &lt;pre&gt;
      #define MAXLEN 1024
      ...
      char *pathbuf[MAXLEN];
      ...
      read(cfgfile,inputbuf,MAXLEN); //does not null terminate
      strcpy(pathbuf,input_buf); //requires null terminated input
      ...
      &lt;/pre&gt;

      The code in Example 1 will behave correctly if the data read from &lt;code&gt;cfgfile&lt;/code&gt; is null terminated on disk as expected. But if an attacker is able to modify this input so that it does not contain the expected &lt;code&gt;NULL&lt;/code&gt; character, the call to &lt;code&gt;strcpy()&lt;/code&gt; will continue copying from memory until it encounters an arbitrary &lt;code&gt;NULL&lt;/code&gt; character. This will likely overflow the destination buffer and, if the attacker can control the contents of memory immediately following &lt;code&gt;inputbuf&lt;/code&gt;, can leave the application susceptible to a buffer overflow attack.

      &lt;b&gt;Example 2:&lt;/b&gt; In the following code, &lt;code&gt;readlink()&lt;/code&gt;expands the name of a symbolic link stored in the buffer &lt;code&gt;path&lt;/code&gt;  so that the buffer &lt;code&gt;filename&lt;/code&gt; contains the absolute path of the file referenced by the symbolic link. The length of the resulting value is then calculated using &lt;code&gt;strlen()&lt;/code&gt;.

      &lt;pre&gt;
      ...
      char buf[MAXPATH];
      ...
      readlink(path, buf, MAXPATH);
      int length = strlen(filename);
      ...
      &lt;/pre&gt;

      The code in Example 2 will not behave correctly because the value read into &lt;code&gt;buf&lt;/code&gt; by &lt;code&gt;readlink()&lt;/code&gt; will not be null terminated. In testing, vulnerabilities like this one might not be caught because the unused contents of &lt;code&gt;buf&lt;/code&gt; and the memory immediately following it may be &lt;code&gt;NULL&lt;/code&gt;, thereby causing &lt;code&gt;strlen()&lt;/code&gt; to appear as if it is behaving correctly. However, in the wild &lt;code&gt;strlen()&lt;/code&gt; will continue traversing memory until it encounters an arbitrary &lt;code&gt;NULL&lt;/code&gt; character on the stack, which results in a value of &lt;code&gt;length&lt;/code&gt; that is much larger than the size of &lt;code&gt;buf&lt;/code&gt; and may cause a buffer overflow in subsequent uses of this value.

      Traditionally, strings are represented as a region of memory containing data terminated with a &lt;code&gt;NULL&lt;/code&gt; character. Older string-handling methods frequently rely on this &lt;code&gt;NULL&lt;/code&gt; character to determine the length of the string. If a buffer that does not contain a &lt;code&gt;NULL&lt;/code&gt; terminator is passed to one of these functions, the function will read past the end of the buffer.

      Malicious users typically exploit this type of vulnerability by injecting data with unexpected size or content into the application. They may provide the malicious input either directly as input to the program or indirectly by modifying application resources, such as configuration files. In the event that an attacker causes the application to read beyond the bounds of a buffer, the attacker may be able use a resulting buffer overflow to inject and execute arbitrary code on the system.
    </Explanation>
    <Recommendations>
      If possible, replace calls to string manipulation functions that rely on null terminated strings with alternatives that manually constrain string length through a length parameter (which should always be bounded by the size of the destination buffer). Only rely on null termination when a bounded equivalent does not exist. In such cases, manually terminate all strings before their use to ensure that subsequent uses of the string will behave as expected.

      Some string manipulation functions are so dangerous that their use should be prohibited entirely. If your security policy forbids the use of these functions, you can enforce the policy by writing custom rules to unconditionally flag these functions during a source analysis of an application. See the custom rule writing section of the Rules Builder documentation for more information.

      Another mechanism for disallowing the use of functions that violate a security policy is to override their definition in a common header. This will cause any use of the function to be flagged as a compiler error.

      For example, to disallow the use of &lt;code&gt;strcat()&lt;/code&gt;:

      &lt;pre&gt;
      #define strcat unsafe_strcat
      &lt;/pre&gt;
    </Recommendations>
    <Tips>
      <Tip>
        At first glance, the following code might appear to correctly handle the fact that &lt;code&gt;readlink()&lt;/code&gt; does not null terminate its output. But read the code carefully; this is an off-by-one error.

        &lt;pre&gt;
        ...
        char buf[MAXPATH];
        int size = readlink(path, buf, MAXPATH);
        if (size != -1) {
        buf[size] = '\0';
        strncpy(filename, buf, MAXPATH);
        length = strlen(filename);
        }
        ...
        &lt;/pre&gt;

        By calling &lt;code&gt;strlen()&lt;/code&gt;, the programmer relies on a string terminator. The programmer has attempted to explicitly null terminate the buffer. The problem with this approach is that it is error-prone. In this example, if &lt;code&gt;readlink()&lt;/code&gt; returns &lt;code&gt;MAXPATH&lt;/code&gt;, then &lt;code&gt;buf[size]&lt;/code&gt; will refer to a location outside of the buffer; &lt;code&gt;strncpy()&lt;/code&gt; will fail to null terminate &lt;code&gt;filename&lt;/code&gt;; and  &lt;code&gt;strlen()&lt;/code&gt; will return an incorrect (and potentially huge) value.
      </Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Writing Secure Code, Second Edition</Title>
        <Author>M. Howard, D. LeBlanc</Author>
        <Publisher>Microsoft Press</Publisher>
        <PublishedDate>2003</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="15677FEB-E366-4407-A0C7-31B92F68F226">
    <Abstract>Allowing an attacker to control a function's format string may result in a buffer overflow.</Abstract>
    <Explanation>
      Format string vulnerabilities occur when an attacker is allowed to control the format string argument to a function like &lt;code&gt;sprintf()&lt;/code&gt;, &lt;code&gt;FormatMessageW()&lt;/code&gt;, or &lt;code&gt;syslog()&lt;/code&gt;.

      In this case the format string for the function &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt; is not constant.

      &lt;b&gt;Example 1:&lt;/b&gt; The following code copies a command line argument into a buffer using &lt;code&gt;snprintf()&lt;/code&gt;.

      &lt;pre&gt;
      int main(int argc, char **argv){
      char buf[128];
      ...
      snprintf(buf,128,argv[1]);
      }
      &lt;/pre&gt;

      The code in Example 1 will allow an attacker to view the contents of the stack and write to the stack by providing a command line argument that has a carefully crafted sequence of formatting directives. Reading from the stack is simply a matter of providing more formatting directives, such as &lt;code&gt;%x&lt;/code&gt;, than the function takes as arguments to be formatted. (In this example, the function takes no arguments to be formatted.)  Writing to the stack can be accomplished using the &lt;code&gt;%n&lt;/code&gt; formatting directive, which causes &lt;code&gt;snprintf()&lt;/code&gt; to write the number of bytes output thus far to the specified argument rather than reading a value from the argument as is usually the case. A sophisticated version of this attack will use four staggered writes to completely control the value of a pointer on the stack.

      Example 2: Certain implementations make more advanced attacks even easier by providing format directives to control the location in memory to read from or write to. An example of these directives is shown in the following code written for glibc:

      &lt;pre&gt;
      printf("%d %d %1$d %1$d\n", 5, 9);
      &lt;/pre&gt;

      This code will produce the following output:

      &lt;pre&gt;
      5 9 5 5
      &lt;/pre&gt;

      It is also possible to use half-writes (%hn) to accurately control arbitrary DWORDS in memory, which greatly reduces the complexity needed to execute an attack that would otherwise require four staggered writes, such as the one described in Example 1.

      Example 3: The simplest format string vulnerabilities are the result of what the programmer might believe to be an innocuous shortcut. At times, these shortcuts become so ingrained that developers are no longer cognizant that the function they are using expects a format string argument. The &lt;code&gt;syslog()&lt;/code&gt; function is sometimes used in the following way:

      &lt;pre&gt;
      ...
      syslog(LOG_ERR, cmdBuf);
      ...
      &lt;/pre&gt;

      However, the second parameter to &lt;code&gt;syslog()&lt;/code&gt; is a format string, so any formatting directives included in cmdBuf will be interpreted as we saw in Example 1. The simplest correct use of &lt;code&gt;syslog()&lt;/code&gt; is this instance would be:

      &lt;pre&gt;
      ...
      syslog(LOG_ERR, "%s", cmdBuf);
      ...
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>Whenever possible, pass static format string to functions that accept a format string argument. If format strings must be constructed dynamically, define a set of valid format strings and make selections from this safe set. Finally, always verify that the number of formatting directives in the selected format string corresponds with the number of arguments passed to the function to be formatted.</Recommendations>
    <References>
      <Reference>
        <Title>Format String Attacks</Title>
        <Author>T. Newsham</Author>
        <Publisher>Guardent, Inc.</Publisher>
        <PublishedDate>2000</PublishedDate>
        <Source></Source>
      </Reference>
    </References>
  </Description>
  <Description classID="95414A7F-C5A3-4E3C-BC41-0630BDED9E36">
    <Abstract>Ignoring a method's return value may cause the program to overlook unexpected states and conditions.</Abstract>
    <Explanation>
      Just about every good attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

      Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". These assumptions are represented by the failure to check the return value from a library function.

      In this case, the value of &lt;sinkfunc&gt; is unchecked in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      &lt;b&gt;Example 1:&lt;/b&gt; Consider the following three lines of code:

      &lt;pre&gt;
      char buf[10], cp_buf[10];
      fgets(buf, 10, stdin);
      strcpy(cp_buf, buf);
      &lt;/pre&gt;

      The programmer expects that when &lt;code&gt;fgets()&lt;/code&gt; returns, &lt;code&gt;buf&lt;/code&gt; will contain a null-terminated string of length 9 or less. But if an I/O error occurs, &lt;code&gt;fgets()&lt;/code&gt; will not null-terminate &lt;code&gt;buf&lt;/code&gt;. Further, if the end-of-file is reached before any characters are read, &lt;code&gt;fgets()&lt;/code&gt; will return without writing anything at all to &lt;code&gt;buf&lt;/code&gt;. In both of these situations &lt;code&gt;fgets()&lt;/code&gt; will signal that something out of the ordinary has happened by returning &lt;code&gt;NULL&lt;/code&gt;, but in this code the warning will go unnoticed. The lack of a null terminator in &lt;code&gt;buf&lt;/code&gt; could easily result in a buffer overflow in the subsequent call to &lt;code&gt;strcpy()&lt;/code&gt;.

      &lt;b&gt;Example 2:&lt;/b&gt;  In the following code, the programmer does not check whether or not memory allocation succeeded before using the memory.

      &lt;pre&gt;
      buf = (char*) malloc(req_size);
      strncpy(buf, xfer, req_size);
      &lt;/pre&gt;

      The traditional defense of this coding error is as follows:

      "If my program runs out of memory, it is doomed to failure. It doesn't matter whether I handle the error or simply seg fault trying to dereference a null pointer".

      This argument ignores three important considerations. First, depending on the type and size of the application, it may be possible to free memory being used elsewhere so that execution may continue. Second, it makes it impossible for the program to perform a graceful exit,(if in fact it is necessary to exit at all). If the program is in the middle of what should be an atomic operation, it may leave the system in an inconsistent state. Third, the programmer has passed up any opportunity to record diagnostic information. Did the call to &lt;code&gt;malloc()&lt;/code&gt; fail because &lt;code&gt;req_size&lt;/code&gt; was enormous, because there were too many requests being handled at the same time, or because of a memory leak that has built up over time?  Without handling the error, there is no way to know.
    </Explanation>
    <Recommendations>
      If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed system call with an ignored return value.

      Create an easy to use and standard way for dealing with failure in your software. If error handling is straightforward, programmers will be less inclined to omit it. One approach standardized error handling is to write wrappers around commonly used functions that check and handle error conditions without additional programmer intervention. If wrappers are implemented and adopted, then the use of non-wrapped equivalents can be prohibited and enforced using custom rules.
    </Recommendations>
    <Tips>
      <Tip>Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...".  Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition may not apply.</Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Building Secure Software</Title>
        <Author>J. Viega, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
    </References>
  </Description>
  <Description classID="DAE45D1C-5AC1-4FBF-9C0A-562A2CE5B482">
    <Abstract>Not accounting for integer overflow may result in logic errors or buffer overflow.</Abstract>
    <Explanation>
      Integer overflow errors occur when a program fails to account for the fact that an arithmetic operation can result in a quantity greater than a data type's maximum value or less than its minimum value. These errors often cause trouble near memory allocation functions where user input intersects with an implicit conversion between signed and unsigned values. If the attacker can cause the program to under-allocate memory or interpret a signed value as unsigned in a memory operation, a buffer overflow may result.

      &lt;b&gt;Example 1:&lt;/b&gt;  The following code excerpt from OpenSSH 3.3 is an ideal demonstration of an integer overflow.

      &lt;pre&gt;
      nresp = packet_get_int();
      if (nresp &gt; 0) {
      response = xmalloc(nresp*sizeof(char*));
      for (i = 0; i &lt; nresp; i++)
      response[i] = packet_get_string(NULL);
      }
      &lt;/pre&gt;

      If &lt;code&gt;nresp&lt;/code&gt; has the value &lt;code&gt;1073741824&lt;/code&gt; and &lt;code&gt;sizeof(char*)&lt;/code&gt; is 4, then the result of the multiplication operation &lt;code&gt;nresp*sizeof(char*)&lt;/code&gt; will overflow, and the argument to &lt;code&gt;xmalloc()&lt;/code&gt; will be 0. Most &lt;code&gt;malloc()&lt;/code&gt; implementations will happily allocate a 0-byte buffer, and every one of the subsequent loop iterations will be part of a heap overflow.

      &lt;b&gt;Example 2:&lt;/b&gt; This example processes user input that is made up of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.

      &lt;pre&gt;
      char* processNext(char* strm) {
      char buf[512];
      short len = * (short*) strm;
      strm += sizeof(len);
      if (len &lt;= 512) {
      memcpy(buf, strm, len);
      process(buf);
      return strm + len;
      } else {
      return -1;
      }
      }
      &lt;/pre&gt;

      The programmer has set an upper bound on the structure size: if it is larger than 512, the input will not be processed. The problem is that &lt;code&gt;len&lt;/code&gt; is a signed integer, so the check against the maximum structure length is done with signed integers, but &lt;code&gt;len&lt;/code&gt; is converted to an unsigned integer for the call to &lt;code&gt;memcpy()&lt;/code&gt;. If &lt;code&gt;len&lt;/code&gt; is negative, then it will appear that the structure has an appropriate size (the &lt;code&gt;if&lt;/code&gt; branch will be taken), but the amount of memory copied by &lt;code&gt;memcpy()&lt;/code&gt; will be large, and the attacker will be able to overflow the stack with their input data.
    </Explanation>
    <Recommendations>
      There are no simple guidelines that allow you to sidestep every integer overflow problem, but these recommendations will help prevent the most egregious cases:

      Pay attention to compiler warnings related to signed/unsigned conversions.  Some programmers may believe that these warnings are innocuous, but they sometimes point out potential overflow problems.

      Be vigilant about checking reasonable upper and lower bounds for all program input.  Even if the program should only be dealing with positive integers, check to be sure that the values you are processing are not less than zero.  (You can eliminate the need for a lower bounds check by using unsigned data types.)

      Be conservative about the range of values you allow.

      Be cognizant of the implicit typecasting that takes place when you call functions, perform arithmetic operations or compare values of different types.

    </Recommendations>
    <Tips>
      <Tip>Consider whether or not the integer that might overflow has been derived from the length of a string. If it has it is safe to assume that the string fits inside the process's address space which puts an upper bound on the string's length. This fact does not make integer overflow impossible in all situations, but it does put additional constraints on the arithmetic that must be performed in order to cause an overflow.</Tip>
    </Tips>
    <References>
      <Reference>
        <Title>Basic Integer Overflows</Title>
        <Author>blexim</Author>
        <Publisher>Phrack</Publisher>
        <Source>http://www.phrack.org/phrack/60/p60-0x0a.txt</Source>
      </Reference>
      <Reference>
        <Title>Coding Flaws That Lead to Security Failures</Title>
        <Author>D. Plakosh</Author>
        <Source>http://iasymposium.tamucc.edu/Plakosh_CodingFlaws.ppt</Source>
      </Reference>
    </References>
  </Description>
  <Description classID="CC65B852-C8FF-4FD2-9515-39BC8F12520F">
    <Abstract>Allowing external control of system settings may disrupt service or cause an application to behave in unexpected ways.</Abstract>
    <Explanation>
      Setting manipulation vulnerabilities occur when an attacker is allowed to control values that govern the behavior of the system, manage specific resources or in some way affect the functionality of the application.

      In this case, potentially malicious data enters at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt; and is passed to a sensitive function at &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      Because setting manipulation covers a diverse set of functions, any attempt at illustrating it will inevitably be incomplete. Rather than searching for a tight-knit relationship between the functions addressed under the name Setting Manipulation, take a step back and consider the sorts of system values that an attacker should not be allowed to control.

      &lt;b&gt;Example 1:&lt;/b&gt; The following C code snippet accepts as one of its command line parameters a number, which it then sets as the Host ID of the current machine.

      &lt;pre&gt;
      ...
      sethostid(argv[1]);
      ...
      &lt;/pre&gt;

      Although a process must be privileged to invoke &lt;code&gt;sethostid()&lt;/code&gt; successfully, that does not necessarily limit which users are able to execute the process. The code in Example 1 allows user input to directly control the value of a privileged system setting. If an attacker provides a malicious value for host ID, the attacker may be able misidentify the affected machine on the network or cause other unintended behavior.

      In general, user provided or otherwise untrusted data should not be allowed to control sensitive values. Frequently, it is not evident how an attacker can leverage the ability to control such values towards an exploitable threat. However, just because our creativity does not match that of the attacker does not eliminate the risk.
    </Explanation>
    <Recommendations>Do not allow untrusted data to control sensitive values. In most cases where such behavior occurs, the application expects a particular input to take on only a very small range of values under normal operating conditions. Where possible, rather than relying on the input to remain within this range, the application should enforce this behavior by using the input to make a selection from a predetermined set of safe values. If the program input is maliciously crafted, the value passed to the sensitive function should default to some safe selection from this set. Even in cases where the set of safe values is not known in advance, it is often possible to validate that the input falls within some safe range of values. If neither of these forms of validation is possible, the application may need to be redesigned in order to avoid the necessity of accepting potentially dangerous values from the user.</Recommendations>
    <Tips>
      <Tip>Do not feel that you need to find a "smoking gun" situation in which the ability of an attacker to control some value leads to an exploitable scenario. The ideal mindset for auditing setting manipulation issues is to ask the question: "Why should a user be allowed to control this value?"</Tip>
    </Tips>
  </Description>
  <Description classID="86C7916D-A73B-4EBE-A235-9E570095EE66">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or cause the execution of malicious code.</Abstract>
    <Explanation>
      &lt;b&gt;Background:&lt;/b&gt; Buffer overflow is probably the best known software security vulnerability. Buffer overflow exploits have existed for years, but both legacy applications and newly developed code continue to fall victim with great regularity. Although almost every software developer has some sense of what a buffer overflow is, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them lead many of today's developers to repeat the mistakes of the past.

      In the canonical buffer overflow exploit, an attacker supplies an unexpectedly large amount of data to a program, and the program stores the data into an undersized stack buffer. Because the attacker's data is too big for the buffer, the data overwrites other information on the call stack including the function's return pointer. The attacker has specially chosen the value that the function pointer is overwritten with, so when the function returns, control jumps to the malicious code that the attacker has cleverly sent along as part of the data.

      Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are also a variety of other buffer overflow types, including heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to make distinctions between types of buffer overflows and the variety of specific exploit techniques used to take advantage of them. There are a number of excellent books that provide detailed information on how buffer overflow attacks work. We recommend Building Secure Software [1], Writing Secure Code [2] and The Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a great variety of ways, but they almost always involve the violation of a programmer's assumptions. Most of the older memory manipulation functions in C and C++ do not perform bounds checking and can easily overwrite the allocated bounds of the buffers they operate upon. Even newer bounded functions like &lt;code&gt;strncpy()&lt;/code&gt; can cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. We propose that most buffer overflows occur in code that:

      1. Relies on external data to control its behavior,

      2. Depends on properties of the data that are enforced outside of the immediate scope of the code, and

      3. Is complex to the point where the programmer cannot make accurate deductions about its behavior.

      In this instance we are primarily concerned with the first case because:

      - External data enters the program at &lt;srcfunc&gt; in &lt;srcfile&gt; at line &lt;srcline&gt;

      &lt;b&gt;AND&lt;/b&gt;

      -	The data affects the manipulation of memory in &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.

      (We will offer examples and comment on the second and third conditions later in this description.)

      &lt;b&gt;Example 1.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read an arbitrary amount of data into a stack buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 1.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2:&lt;/b&gt; The code in this example also relies on user input to control its behavior, but it adds a level of indirection . Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer, and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Buffer overflows of this type, where a program reads data and then trusts a value from the data to perform memory operations on the remaining data have cropped up with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 3:&lt;/b&gt; Below is the implantation of a function named &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on its input, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that are not enforced locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;length&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, and if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or
      &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info) {
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI functions defined in &lt;code&gt;strsafe.h &lt;/code&gt;[4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not solve the buffer overflow problem.

      Whenever you manipulate memory, especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never trust an external source to provide correct control information to be used in a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; go out of your way to make it simple and clearly document the checks you perform, the assumptions that you verify, and what the expected behavior is in the case that input validation fails. When input data is too large, watch out for problems that may result from simply truncating the data--truncation may change the meaning of the input.

      Finally, do not rely on tools like StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools are unable to address heap buffer overflows and more subtle stack overflows that simply change the contents variables used to control the program. Additionally, these tools can almost always be defeated, and even when they are working properly they treat the symptoms rather than the causes of buffer overflow.
    </Recommendations>
    <References>
      <Reference>
        <Title>Building Secure Software</Title>
        <Author>J. Viega, G. McGraw</Author>
        <Publisher>Addison-Wesley</Publisher>
        <PublishedDate>2002</PublishedDate>
      </Reference>
      <Reference>
        <Title>Writing Secure Code, Second Edition</Title>
        <Author>M. Howard, D. LeBlanc</Author>
        <Publisher>Microsoft Press</Publisher>
        <PublishedDate>2003</PublishedDate>
      </Reference>
      <Reference>
        <Title>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</Title>
        <Author>J. Koziol et al.</Author>
        <Publisher>John Wiley &amp; Sons</Publisher>
        <PublishedDate>2004</PublishedDate>
      </Reference>
      <Reference>
        <Title>Strsafe.h Functions</Title>
        <Publisher>Microsoft</Publisher>
        <Source>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/resources/strings/usingstrsafefunctions.asp</Source>
      </Reference>
    </References>
  </Description>
  <Description classID="635A356B-CF51-420F-956E-54E0933AB305">
    <Abstract>Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or allow the execution of malicious code.</Abstract>
    <Explanation>
      Background: The buffer overflow is probably the best know security vulnerability in software. Exploits of buffer overflow vulnerabilities have existed for years, but both legacy applications and newly developed code continue to fall victim with alarming regularity. Although nearly every software developer has heard of buffer overflows, the variety of ways these vulnerabilities can occur and the seemingly complex mechanisms for preventing them relegate many of today's developers to repeat the mistakes of the past.

      The canonical exploit of a buffer overflow occurs when an attacker supplies data to a program, which it stores in a stack allocated buffer, overflowing the bounds of the buffer. Rather than arbitrary data, the attacker supplies a segment of malicious code followed by values designed to overwrite the return value of the function and cause it to jump into and begin executing the code stored in the buffer. Although this type of stack buffer overflow is quite common, there are also a variety of other types, such as heap buffer overflows and off-by-ones-errors, among others. For the sake of brevity we will not attempt to explain the distinct types of buffer overflows and the variety of specific exploits used against them. If you want to read more on this topic there are a variety of excellent books that provide further discussion. We recommend Building Secure Software [1], Writing Secure Code [2] and Shellcoder's Handbook [3].

      At the code level, buffer overflows can occur in a variety of ways, but they almost always involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking, and thus can easily exceed the allocated bounds of the buffers they operate on. Even bounded functions, such as &lt;code&gt;n&lt;/code&gt; functions like &lt;code&gt;strncpy()&lt;/code&gt;, can easily cause vulnerabilities when used incorrectly. The combination of memory manipulation and false assumptions about the size or makeup of the data is the root cause of most buffer overflows; but clearly this pattern is very open ended. In order to clarify this statement we propose that most buffer overflows occur in programs that perform memory operations in code that:

      1. Relies on external data to control any part of its behavior.

      2. Depends on properties of data that are enforced outside of its immediate scope.

      3. Is overly complex to the point where a human can no longer make accurate deductions about its behavior.

      In this case we are primarily concerned with the second case, because we cannot verify the safety of the operation performed by &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;. (We will also offer examples and comment on scenarios one and three.)

      &lt;b&gt;Example 1:&lt;/b&gt; Below is an implantation of the function &lt;code&gt;lccopy()&lt;/code&gt;, which takes a string for its argument and returns a heap allocated copy of the string with all uppercase letters converted to lowercase. The function does not perform any bounds checking on the input &lt;code&gt;str&lt;/code&gt;, which indicates that it expects &lt;code&gt;str&lt;/code&gt; to always be smaller than &lt;code&gt;BUFSIZE&lt;/code&gt;. If an attacker bypasses checks in the code that calls &lt;code&gt;lccopy()&lt;/code&gt; or if a change in that code makes the assumption about the size of &lt;code&gt;str&lt;/code&gt; no longer true, then &lt;code&gt;lccopy()&lt;/code&gt; will overflow the &lt;code&gt;buf&lt;/code&gt; with the unbounded call to &lt;code&gt;strcpy()&lt;/code&gt;.This is an example of code that depends on properties of its data that it does not enforce locally.

      &lt;pre&gt;
      char *lccopy(const char *str) {
      char buf[BUFSIZE];
      char *p;

      strcpy(buf, str);
      for (p = buf; *p; p++) {
      if (isupper(*p)) {
      *p = tolower(*p);
      }
      }
      return strdup(buf);
      }
      &lt;/pre&gt;

      &lt;b&gt;Example 2.a:&lt;/b&gt; The following code is an example of the simplest buffer overflow we could think of. It uses the &lt;code&gt;gets()&lt;/code&gt; function to read (an arbitrary amount) of data into a stack allocated buffer. Because there is no way to limit the amount of data read by &lt;code&gt;gets()&lt;/code&gt;, the program trusts that the user will enter less than &lt;code&gt;BUFSIZE&lt;/code&gt; characters. This is an example of the first scenario that often produces buffer overflows: code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      gets(buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 2.b:&lt;/b&gt; In C++ its easy to mimic the unsafe behavior of &lt;code&gt;gets()&lt;/code&gt; by using the &lt;code&gt;&gt;&gt;&lt;/code&gt; operator to read input into a &lt;code&gt;char[]&lt;/code&gt; string.

      &lt;pre&gt;
      ...
      char buf[BUFSIZE];
      cin &gt;&gt; (buf);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Example 3:&lt;/b&gt; The code in Example 2 also relies on user input to control its behavior, but adds a level of indirection to what we saw in Example 1. Here the programmer is using the bounded memory copy function &lt;code&gt;memcpy()&lt;/code&gt;, which accepts a destination buffer, a source buffer and the number of bytes to copy. The input buffer is filled with a bounded call to &lt;code&gt;read()&lt;/code&gt;, but the number of bytes for &lt;code&gt;memcpy()&lt;/code&gt; to copy is also read from the user. This is another example code that relies on external data to control its behavior.

      &lt;pre&gt;
      ...
      char buf[64], in[MAX_SIZE];
      printf("Enter buffer contents:\n");
      read(0, in, MAX_SIZE-1);
      printf("Bytes to copy:\n");
      scanf("%d", &amp;bytes);
      memcpy(buf, in, bytes);
      ...
      &lt;/pre&gt;

      &lt;b&gt;Note:&lt;/b&gt; Vulnerabilities of this type, where a program reads data and then uses a size value read from an external source to perform an operation on the data have occurred with some frequency in image, audio and other file processing libraries.

      &lt;b&gt;Example 4:&lt;/b&gt; The following code was found fairly recently in the popular libPNG image decoder, which is used by various applications like Mozilla and some versions of Internet Explorer. At first glance it appears that the code might be safe because it is performing a size check on the variable length, which it later relies on to control the amount of data copied by &lt;code&gt;png_crc_read()&lt;/code&gt;. It is hard to say just from glancing at the code quickly, and a first reaction might be: "The code does bounds checking when it tests the value of &lt;code&gt;legnth&lt;/code&gt;, so it must be safe." But this check relies on faulty logic. Immediately before it tests length, the code performs a check on &lt;code&gt;png_ptr-&gt;mode&lt;/code&gt;, if this check fails a warning is issued and processing continues. However, because &lt;code&gt;length&lt;/code&gt; is tested in an &lt;code&gt;else if&lt;/code&gt; block, if the first check fails then &lt;code&gt;length&lt;/code&gt; is never tested and is used blindly in the call to &lt;code&gt;png_crc_read()&lt;/code&gt;, causing a stack buffer overflow. Although the code in this example is not the most complex that we have seen, it does illustrate the point that any complexity related to sensitive memory operations is unwanted.

      &lt;pre&gt;
      if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
      }
      ...
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      &lt;/pre&gt;

      &lt;b&gt;Example 5:&lt;/b&gt; The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string. This function incorrectly passes the size of &lt;code&gt;unicodeUser&lt;/code&gt; in bytes rather than characters. The call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; may therefore write up to &lt;code&gt;(UNLEN+1)*sizeof(WCHAR&lt;/code&gt;) wide characters, or (&lt;code&gt;UNLEN+1)*sizeof(WCHAR)*
      sizeof(WCHAR)&lt;/code&gt; bytes, to the &lt;code&gt;unicodeUser&lt;/code&gt; array, which has only &lt;code&gt;(UNLEN+1)*sizeof(WCHAR)&lt;/code&gt; bytes allocated. If the &lt;code&gt;username&lt;/code&gt; string contains more than &lt;code&gt;UNLEN&lt;/code&gt; characters, the call to &lt;code&gt;MultiByteToWideChar()&lt;/code&gt; will overflow the buffer &lt;code&gt;unicodeUser&lt;/code&gt;. Complexity is the primary cause of this buffer overflow as well, but this time the culprit is the interface of one of the functions used rather the structure of the code itself.

      &lt;pre&gt;
      void getUserInfo(char *username, struct _USER_INFO_2 info){
      WCHAR unicodeUser[UNLEN+1];
      MultiByteToWideChar(CP_ACP, 0, username, -1,
      unicodeUser, sizeof(unicodeUser));
      NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);
      }
      &lt;/pre&gt;
    </Explanation>
    <Recommendations>
      Never use inherently unsafe functions like &lt;code&gt;gets()&lt;/code&gt; and avoid the use of functions that are difficult to use safely &lt;code&gt;strcpy()&lt;/code&gt;. Replace unbounded functions, such as &lt;code&gt;strcpy()&lt;/code&gt;, with their bounded equivalents, such as &lt;code&gt;strncpy()&lt;/code&gt; or the WinAPI string functions defined in &lt;code&gt;strsafe.h&lt;/code&gt; [4]. Although the careful use of bounded functions can greatly reduce the risk of buffer overflow, this migration cannot be done blindly and does not go far enough on its own to ensure security.

      Whenever you manipulate memory, and especially strings, be mindful of the three scenarios where buffer overflows are likely to occur. Never rely on an external source to control any aspect of a memory operation. Never trust that certain properties about the data you are operating on will hold without verifying them yourself. Limit the complexity of memory manipulation and bounds checking code; make it as simple as possible and clearly document what checks are performed, what assumptions hold or are verified and what the expected behavior is. When data input data is too large, watch out for problems that may result from simply truncating data -- this may not be the right way to handle the error and lead to other issues because the data will likely be malformed.

      Finally, do not rely on tools such as StackGuard or non-executable stacks to prevent buffer overflow vulnerabilities. These tools can almost always be defeated and treat the symptoms rather than the cause of buffer overflows -- the software. They are also unable to address the threats of heap buffer overflows and more subtle overflows that simply change the contents variables used to control the program.
    </Recommendations>
  </Description>
  <Description classID="6F195230-103C-42F3-930D-8ACA743407EE">
    <Abstract>Functions with inconsistent implementations across operating systems and operating system versions may cause portability problems.</Abstract>
    <Explanation>
      The behavior of functions in this category varies from one operating system to another, and at times even from one operating system version to the next. The degree to which the behavior varies ranges from slight differences that may cause the function to be misused, through versions of the function with significant security risks, to platforms where the function is not defined at all. In all of these cases the common factor is that the behavior of the function is unpredictable depending on where it is used.

      In this case the inconsistent function you are using is &lt;sinkfunc&gt; in &lt;sinkfile&gt; at line &lt;sinkline&gt;.
    </Explanation>
    <Recommendations>If portability is a concern for your application, functions with inconsistent implementations should be avoided. There are cases where the inconsistent function can be shored up, such as certain versions of &lt;code&gt;getopt()&lt;/code&gt; that suffer from an internal buffer overflow if the size of their input is not sufficiently checked. However, far more often the problem cannot be avoid, such as the varying implementations of &lt;code&gt;vfork()&lt;/code&gt; on different systems or the fact that &lt;code&gt;strcmpi()&lt;/code&gt; is simply not defined on some Unix platforms. Other times, the problem is that function behavior changes between versions, such as &lt;code&gt;memem()&lt;/code&gt; where the order of the arguments was reversed. In general, replace calls to functions that are implemented inconsistently with safe counterparts. </Recommendations>
  </Description>
  <Snippets>
    <Snippet id="log.c:152:152">
      <File>log.c</File>
      <StartLine>149</StartLine>
      <EndLine>155</EndLine>
      <Text>
        <![CDATA[        return;
    va_start(arglist, format);
#ifdef HAVE_VSNPRINTF
    vsnprintf(text, 256, format, arglist);
#else
    vsprintf(text, format, arglist);
#endif
]]>
      </Text>
    </Snippet>
    <Snippet id="log.c:164:164">
      <File>log.c</File>
      <StartLine>161</StartLine>
      <EndLine>166</EndLine>
      <Text>
        <![CDATA[#endif
        fprintf(stderr, "LOG%d[%lu:%lu]: %s\n",
            level, process_id(), thread_id(), text);
    fflush(stderr);
}

]]>
      </Text>
    </Snippet>
    <Snippet id="protocol.c:145:145">
      <File>protocol.c</File>
      <StartLine>142</StartLine>
      <EndLine>148</EndLine>
      <Text>
        <![CDATA[
    va_start(arglist, format);
#ifdef HAVE_VSNPRINTF
    len=vsnprintf(line, STRLEN, format, arglist);
#else
    len=vsprintf(line, format, arglist);
#endif
]]>
      </Text>
    </Snippet>
    <Snippet id="protocol.c:169:169">
      <File>protocol.c</File>
      <StartLine>166</StartLine>
      <EndLine>172</EndLine>
      <Text>
        <![CDATA[
    ptr=0;
    for(;;) {
        switch(readsocket(fd, line+ptr, 1)) {
        case -1: /* error */
            sockerror("readsocket (fdscanf)");
            return -1;
]]>
      </Text>
    </Snippet>
    <Snippet id="protocol.c:186:186">
      <File>protocol.c</File>
      <StartLine>183</StartLine>
      <EndLine>189</EndLine>
      <Text>
        <![CDATA[    }
    line[ptr]='\0';
    log(LOG_DEBUG, " <- %s", line);
    return sscanf(line, format, buffer);
}

/* 
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:76:76">
      <File>pty.c</File>
      <StartLine>73</StartLine>
      <EndLine>79</EndLine>
      <Text>
        <![CDATA[        sockerror("openpty");
        return -1;
    }
    safecopy(namebuf, buf); /* possible truncation */
    return 0;
#else /* HAVE_OPENPTY */
#ifdef HAVE__GETPTY
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:227:227">
      <File>pty.c</File>
      <StartLine>224</StartLine>
      <EndLine>230</EndLine>
      <Text>
        <![CDATA[
    /* First disconnect from the old controlling tty. */
#ifdef TIOCNOTTY
    fd = open("/dev/tty", O_RDWR | O_NOCTTY);
    if (fd >= 0) {
        (void) ioctl(fd, TIOCNOTTY, NULL);
        close(fd);
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:229:229">
      <File>pty.c</File>
      <StartLine>226</StartLine>
      <EndLine>232</EndLine>
      <Text>
        <![CDATA[#ifdef TIOCNOTTY
    fd = open("/dev/tty", O_RDWR | O_NOCTTY);
    if (fd >= 0) {
        (void) ioctl(fd, TIOCNOTTY, NULL);
        close(fd);
    }
#endif /* TIOCNOTTY */
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:240:240">
      <File>pty.c</File>
      <StartLine>237</StartLine>
      <EndLine>243</EndLine>
      <Text>
        <![CDATA[     * Verify that we are successfully disconnected from the controlling
     * tty.
     */
    fd = open("/dev/tty", O_RDWR | O_NOCTTY);
    if (fd >= 0) {
        log(LOG_ERR, "Failed to disconnect from controlling tty.");
        close(fd);
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:253:253">
      <File>pty.c</File>
      <StartLine>250</StartLine>
      <EndLine>256</EndLine>
      <Text>
        <![CDATA[     * returns EINVAL with these arguments, and there is absolutely no
     * documentation.
     */
    ioctl(*ttyfd, TIOCSCTTY, NULL);
#endif /* TIOCSCTTY */
    fd = open(ttyname, O_RDWR);
    if (fd < 0)
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:255:255">
      <File>pty.c</File>
      <StartLine>252</StartLine>
      <EndLine>258</EndLine>
      <Text>
        <![CDATA[     */
    ioctl(*ttyfd, TIOCSCTTY, NULL);
#endif /* TIOCSCTTY */
    fd = open(ttyname, O_RDWR);
    if (fd < 0)
        sockerror(ttyname);
    else
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:262:262">
      <File>pty.c</File>
      <StartLine>259</StartLine>
      <EndLine>265</EndLine>
      <Text>
        <![CDATA[        close(fd);

    /* Verify that we now have a controlling tty. */
    fd = open("/dev/tty", O_WRONLY);
    if (fd < 0)
        sockerror("open /dev/tty failed - could not set controlling tty");
    else {
]]>
      </Text>
    </Snippet>
    <Snippet id="pty.c:268:268">
      <File>pty.c</File>
      <StartLine>265</StartLine>
      <EndLine>271</EndLine>
      <Text>
        <![CDATA[    else {
        close(fd);
    }
}

/* End of stunnel.c */

]]>
      </Text>
    </Snippet>
    <Snippet id="ssl.c:663:663">
      <File>ssl.c</File>
      <StartLine>660</StartLine>
      <EndLine>666</EndLine>
      <Text>
        <![CDATA[                goto error;
            }
            if(num) {
                memcpy(ssl_buff, ssl_buff+num, ssl_ptr-num);

                if (ssl_ptr ==BUFFSIZE) check_SSL_pending = 1;

]]>
      </Text>
    </Snippet>
    <Snippet id="ssl.c:691:691">
      <File>ssl.c</File>
      <StartLine>688</StartLine>
      <EndLine>694</EndLine>
      <Text>
        <![CDATA[
            switch(SSL_get_error(ssl, num)) {
            case SSL_ERROR_NONE:
                memcpy(sock_buff, sock_buff+num, sock_ptr-num);
                sock_ptr-=num;
                ssl_bytes+=num;
                break;
]]>
      </Text>
    </Snippet>
    <Snippet id="ssl.c:716:716">
      <File>ssl.c</File>
      <StartLine>713</StartLine>
      <EndLine>719</EndLine>
      <Text>
        <![CDATA[        }

        if(sock_open && FD_ISSET(sock_fd, &rd_set)) {
            num=readsocket(sock_fd, sock_buff+sock_ptr, BUFFSIZE-sock_ptr);

            if(num<0 && errno==ECONNRESET) {
                log(LOG_NOTICE, "IPC reset (child died)");
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:141:141">
      <File>stunnel.c</File>
      <StartLine>138</StartLine>
      <EndLine>144</EndLine>
      <Text>
        <![CDATA[server_options options;

    /* Functions */
int main(int argc, char* argv[])
{ /* execution begins here 8-) */
    struct stat st; /* buffer for stat */

]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:164:164">
      <File>stunnel.c</File>
      <StartLine>161</StartLine>
      <EndLine>167</EndLine>
      <Text>
        <![CDATA[    options.cert_defaults = CERT_DEFAULTS;
    
    safecopy(options.pem, PEM_DIR);
    if ( options.pem[0] ) { safeconcat(options.pem, "/"); }
    safeconcat(options.pem, "stunnel.pem");

    get_options(argc, argv);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:165:165">
      <File>stunnel.c</File>
      <StartLine>162</StartLine>
      <EndLine>168</EndLine>
      <Text>
        <![CDATA[    
    safecopy(options.pem, PEM_DIR);
    if ( options.pem[0] ) { safeconcat(options.pem, "/"); }
    safeconcat(options.pem, "stunnel.pem");

    get_options(argc, argv);
    if(!(options.option&OPT_FOREGROUND)) {
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:167:167">
      <File>stunnel.c</File>
      <StartLine>164</StartLine>
      <EndLine>170</EndLine>
      <Text>
        <![CDATA[    if ( options.pem[0] ) { safeconcat(options.pem, "/"); }
    safeconcat(options.pem, "stunnel.pem");

    get_options(argc, argv);
    if(!(options.option&OPT_FOREGROUND)) {
        options.foreground=0;
        log_open();
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:246:246">
      <File>stunnel.c</File>
      <StartLine>243</StartLine>
      <EndLine>249</EndLine>
      <Text>
        <![CDATA[    options.rand_write=1;
    options.random_bytes=RANDOM_BYTES;
    opterr=0;
    while ((c = getopt(argc, argv, "A:a:cp:v:d:fTl:L:r:s:g:t:u:n:N:hC:D:E:R:WB:VP:S:")) != EOF)
        switch (c) {
	    case 'A':
	    	safecopy(options.cert_file,optarg);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:546:546">
      <File>stunnel.c</File>
      <StartLine>543</StartLine>
      <EndLine>549</EndLine>
      <Text>
        <![CDATA[	safeconcat(options.pidfile, ".pid");
#endif
    } else {
    	safecopy(options.pidfile, options.pid_dir);
    }

    /* silently remove old pid file */
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:550:550">
      <File>stunnel.c</File>
      <StartLine>547</StartLine>
      <EndLine>553</EndLine>
      <Text>
        <![CDATA[    }

    /* silently remove old pid file */
    unlink(options.pidfile);
    if (-1==(pf=open(options.pidfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL,0644))) {
        log(LOG_ERR, "Cannot create pid file %s", options.pidfile);
	ioerror("Create");
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:551:551">
      <File>stunnel.c</File>
      <StartLine>548</StartLine>
      <EndLine>554</EndLine>
      <Text>
        <![CDATA[
    /* silently remove old pid file */
    unlink(options.pidfile);
    if (-1==(pf=open(options.pidfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL,0644))) {
        log(LOG_ERR, "Cannot create pid file %s", options.pidfile);
	ioerror("Create");
	exit(1);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:568:568">
      <File>stunnel.c</File>
      <StartLine>565</StartLine>
      <EndLine>571</EndLine>
      <Text>
        <![CDATA[    log(LOG_DEBUG, "removing pid file %s", options.pidfile);
    if((unsigned long)getpid()!=options.dpid)
        return; /* Current process is not main daemon process */
    if(unlink(options.pidfile)<0)
        ioerror(options.pidfile); /* not critical */
}
#endif /* defined USE_WIN32 */
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:606:606">
      <File>stunnel.c</File>
      <StartLine>603</StartLine>
      <EndLine>609</EndLine>
      <Text>
        <![CDATA[        struct group *gr;
        gid_t gr_list[1];

        gr=getgrnam(options.setgid_group);
        if(!gr) {
            log(LOG_ERR, "Failed to get GID for group %s",
                options.setgid_group);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:612:612">
      <File>stunnel.c</File>
      <StartLine>609</StartLine>
      <EndLine>615</EndLine>
      <Text>
        <![CDATA[                options.setgid_group);
            exit(1);
        }
        if(setgid(gr->gr_gid)) {
            sockerror("setgid");
            exit(1);
        }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:616:616">
      <File>stunnel.c</File>
      <StartLine>613</StartLine>
      <EndLine>619</EndLine>
      <Text>
        <![CDATA[            sockerror("setgid");
            exit(1);
        }
        gr_list[0]=gr->gr_gid;
        if(setgroups(1, gr_list)) {
            sockerror("setgroups");
            exit(1);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:617:617">
      <File>stunnel.c</File>
      <StartLine>614</StartLine>
      <EndLine>620</EndLine>
      <Text>
        <![CDATA[            exit(1);
        }
        gr_list[0]=gr->gr_gid;
        if(setgroups(1, gr_list)) {
            sockerror("setgroups");
            exit(1);
        }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:638:638">
      <File>stunnel.c</File>
      <StartLine>635</StartLine>
      <EndLine>641</EndLine>
      <Text>
        <![CDATA[		log(LOG_ERR, "Failed to chown pidfile %s", options.pidfile);
	}
#endif
        if(setuid(pw->pw_uid)) {
            sockerror("setuid");
            exit(1);
        }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:692:692">
      <File>stunnel.c</File>
      <StartLine>689</StartLine>
      <EndLine>695</EndLine>
      <Text>
        <![CDATA[            putenv("LD_PRELOAD=" libdir "/stunnel.so");
            addr.s_addr = ip;
            safecopy(text, "REMOTE_HOST=");
            safeconcat(text, inet_ntoa(addr));
            putenv(text);
        }
        execvp(options.execname, options.execargs);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:695:695">
      <File>stunnel.c</File>
      <StartLine>692</StartLine>
      <EndLine>698</EndLine>
      <Text>
        <![CDATA[            safeconcat(text, inet_ntoa(addr));
            putenv(text);
        }
        execvp(options.execname, options.execargs);
        ioerror("execvp"); /* execv failed */
        exit(1);
    }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:782:782">
      <File>stunnel.c</File>
      <StartLine>779</StartLine>
      <EndLine>785</EndLine>
      <Text>
        <![CDATA[    }
    ptr=0;
    do {
        len=readsocket(s, buff+ptr, STRLEN-ptr-1);
        if(len<0) {
            sockerror("readsocket (ident)");
            closesocket(s);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:792:792">
      <File>stunnel.c</File>
      <StartLine>789</StartLine>
      <EndLine>795</EndLine>
      <Text>
        <![CDATA[    } while(len && ptr<STRLEN-1);
    closesocket(s);
    buff[ptr]='\0';
    if(sscanf(buff, "%*[^:]: USERID :%*[^:]:%s", name)!=1) {
        log(LOG_ERR, "Incorrect data from inetd server");
        return -1;
    }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:797:797">
      <File>stunnel.c</File>
      <StartLine>794</StartLine>
      <EndLine>800</EndLine>
      <Text>
        <![CDATA[        return -1;
    }
    log(LOG_INFO, "IDENT resolved remote user to %s", name);
    if(strcmp(name, options.username))
        return -1;
    return 0;
}
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:898:898">
      <File>stunnel.c</File>
      <StartLine>895</StartLine>
      <EndLine>901</EndLine>
      <Text>
        <![CDATA[        return;
    }
    /* not dotted decimal - we have to call resolver */
    if(!(h=gethostbyname(hostname))) { /* get list of addresses */
        sockerror("gethostbyname");
        exit(1);
    }
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:903:903">
      <File>stunnel.c</File>
      <StartLine>900</StartLine>
      <EndLine>906</EndLine>
      <Text>
        <![CDATA[        exit(1);
    }
    i=0;
    tab=h->h_addr_list;
    while(*tab++) /* count the addresses */
        i++;
    alloc(hostlist, i); /* allocate memory */
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:906:906">
      <File>stunnel.c</File>
      <StartLine>903</StartLine>
      <EndLine>909</EndLine>
      <Text>
        <![CDATA[    tab=h->h_addr_list;
    while(*tab++) /* count the addresses */
        i++;
    alloc(hostlist, i); /* allocate memory */
    while(--i>=0)
        (*hostlist)[i]=*(u32 *)(h->h_addr_list[i]);
}
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:1007:1007">
      <File>stunnel.c</File>
      <StartLine>1004</StartLine>
      <EndLine>1010</EndLine>
      <Text>
        <![CDATA[{ /* Allocate len+1 words terminated with -1 */
    if (*ptr) /* Deallocate if not null */
        free(*ptr);
    *ptr=malloc((len+1)*sizeof(u32));
    if (!*ptr) {
        log(LOG_ERR, "Fatal memory allocation error");
        exit(2);
]]>
      </Text>
    </Snippet>
    <Snippet id="stunnel.c:1012:1012">
      <File>stunnel.c</File>
      <StartLine>1009</StartLine>
      <EndLine>1015</EndLine>
      <Text>
        <![CDATA[        log(LOG_ERR, "Fatal memory allocation error");
        exit(2);
    }
    (*ptr)[len]=-1;
}

static void print_version()
]]>
      </Text>
    </Snippet>
  </Snippets>
  <ProgramData>
    <Sources>
      <SourceInstance ruleID="73602E8D-0EC9-46B2-98C2-62E51F441B71">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="626"
              lineEnd="626" colStart="0" colEnd="0" snippet="stunnel.c:626:626"/>
          <Function name="getpwnam"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="NULL_TERMINATED"/>
          <TaintFlag name="FILE_SYSTEM"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="39DDF4FD-5A7A-4BFF-AEC4-05A8232615B1">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="782"
              lineEnd="782" colStart="0" colEnd="0" snippet="stunnel.c:782:782"/>
          <Function name="read"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="STREAM"/>
          <TaintFlag name="NOT_NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="ACEDD018-EA76-47B9-A765-21CB8C6701DA">
        <FunctionCall>
          <SourceLocation path="env.c" line="37" lineEnd="37"
              colStart="0" colEnd="0" snippet="env.c:37:37"/>
          <Function name="getenv"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="ENVIRONMENT"/>
          <TaintFlag name="NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="73602E8D-0EC9-46B2-98C2-62E51F441B71">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="756"
              lineEnd="756" colStart="0" colEnd="0" snippet="stunnel.c:756:756"/>
          <Function name="getservbyname"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="NULL_TERMINATED"/>
          <TaintFlag name="FILE_SYSTEM"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="39DDF4FD-5A7A-4BFF-AEC4-05A8232615B1">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="716"
              lineEnd="716" colStart="0" colEnd="0" snippet="ssl.c:716:716"/>
          <Function name="read"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="STREAM"/>
          <TaintFlag name="NOT_NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="73602E8D-0EC9-46B2-98C2-62E51F441B71">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="606"
              lineEnd="606" colStart="0" colEnd="0" snippet="stunnel.c:606:606"/>
          <Function name="getgrnam"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="NULL_TERMINATED"/>
          <TaintFlag name="FILE_SYSTEM"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="054DFA59-0195-4AB2-B12C-C89C8650F4A5">
        <FunctionEntry>
          <SourceLocation path="stunnel.c" line="141"
              lineEnd="141" colStart="0" colEnd="0" snippet="stunnel.c:141:141"/>
          <Function name="main"/>
        </FunctionEntry>
        <TaintFlags>
          <TaintFlag name="ARGS"/>
          <TaintFlag name="NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="A1796E75-AE27-4C8B-9BB6-F2B0D9985B61">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="898"
              lineEnd="898" colStart="0" colEnd="0" snippet="stunnel.c:898:898"/>
          <Function name="gethostbyname"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="73602E8D-0EC9-46B2-98C2-62E51F441B71">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="873"
              lineEnd="873" colStart="0" colEnd="0" snippet="stunnel.c:873:873"/>
          <Function name="getservbyname"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="NULL_TERMINATED"/>
          <TaintFlag name="FILE_SYSTEM"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="ACEDD018-EA76-47B9-A765-21CB8C6701DA">
        <FunctionCall>
          <SourceLocation path="env.c" line="33" lineEnd="33"
              colStart="0" colEnd="0" snippet="env.c:33:33"/>
          <Function name="getenv"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="ENVIRONMENT"/>
          <TaintFlag name="NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
      <SourceInstance ruleID="39DDF4FD-5A7A-4BFF-AEC4-05A8232615B1">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="169"
              lineEnd="169" colStart="0" colEnd="0" snippet="protocol.c:169:169"/>
          <Function name="read"/>
        </FunctionCall>
        <TaintFlags>
          <TaintFlag name="STREAM"/>
          <TaintFlag name="NOT_NULL_TERMINATED"/>
        </TaintFlags>
      </SourceInstance>
    </Sources>
    <Sinks>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1038"
              lineEnd="1038" colStart="0" colEnd="0" snippet="stunnel.c:1038:1038"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="18270A3F-B869-43FD-A094-8CAF6B58768A">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="207"
              lineEnd="207" colStart="0" colEnd="0" snippet="protocol.c:207:207"/>
          <Function name="memset"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="691"
              lineEnd="691" colStart="0" colEnd="0" snippet="stunnel.c:691:691"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1032"
              lineEnd="1032" colStart="0" colEnd="0" snippet="stunnel.c:1032:1032"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="28424EC3-FFAC-40C0-94D9-3D8283B2F57C">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="792"
              lineEnd="792" colStart="0" colEnd="0" snippet="stunnel.c:792:792"/>
          <Function name="sscanf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="54"
              lineEnd="54" colStart="0" colEnd="0" snippet="protocol.c:54:54"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="log.c" line="101"
              lineEnd="101" colStart="0" colEnd="0" snippet="log.c:101:101"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1036"
              lineEnd="1036" colStart="0" colEnd="0" snippet="stunnel.c:1036:1036"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="pty.c" line="76" lineEnd="76"
              colStart="0" colEnd="0" snippet="pty.c:76:76"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="04139B1E-4D92-42C7-8888-156ED23703F6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="755"
              lineEnd="755" colStart="0" colEnd="0" snippet="stunnel.c:755:755"/>
          <Function name="memcpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="log.c" line="130"
              lineEnd="130" colStart="0" colEnd="0" snippet="log.c:130:130"/>
          <Function name="strcasecmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="DFD1F0B7-9729-49C9-8558-46E615A8C296">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="165"
              lineEnd="165" colStart="0" colEnd="0" snippet="stunnel.c:165:165"/>
          <Function name="strncat"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="log.c" line="120"
              lineEnd="120" colStart="0" colEnd="0" snippet="log.c:120:120"/>
          <Function name="strtok"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1029"
              lineEnd="1029" colStart="0" colEnd="0" snippet="stunnel.c:1029:1029"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="431"
              lineEnd="431" colStart="0" colEnd="0" snippet="stunnel.c:431:431"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1034"
              lineEnd="1034" colStart="0" colEnd="0" snippet="stunnel.c:1034:1034"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="CC65B852-C8FF-4FD2-9515-39BC8F12520F">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="617"
              lineEnd="617" colStart="0" colEnd="0" snippet="stunnel.c:617:617"/>
          <Function name="setgroups"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="B6725097-5284-4CB8-80B2-6D3C18058160">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="782"
              lineEnd="782" colStart="0" colEnd="0" snippet="stunnel.c:782:782"/>
          <Function name="read"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="04139B1E-4D92-42C7-8888-156ED23703F6">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="663"
              lineEnd="663" colStart="0" colEnd="0" snippet="ssl.c:663:663"/>
          <Function name="memcpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="163"
              lineEnd="163" colStart="0" colEnd="0" snippet="stunnel.c:163:163"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="log.c" line="111"
              lineEnd="111" colStart="0" colEnd="0" snippet="log.c:111:111"/>
          <Function name="strcasecmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="374"
              lineEnd="374" colStart="0" colEnd="0" snippet="stunnel.c:374:374"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1039"
              lineEnd="1039" colStart="0" colEnd="0" snippet="stunnel.c:1039:1039"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="66"
              lineEnd="66" colStart="0" colEnd="0" snippet="protocol.c:66:66"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="518"
              lineEnd="518" colStart="0" colEnd="0" snippet="stunnel.c:518:518"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="858"
              lineEnd="858" colStart="0" colEnd="0" snippet="stunnel.c:858:858"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1053"
              lineEnd="1053" colStart="0" colEnd="0" snippet="stunnel.c:1053:1053"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="pty.c" line="262"
              lineEnd="262" colStart="0" colEnd="0" snippet="pty.c:262:262"/>
          <Function name="open"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="log.c" line="106"
              lineEnd="106" colStart="0" colEnd="0" snippet="log.c:106:106"/>
          <Function name="strchr"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="7467DE18-5588-416C-979E-CFCDBD24BE77">
        <FunctionCall>
          <SourceLocation path="log.c" line="152"
              lineEnd="152" colStart="0" colEnd="0" snippet="log.c:152:152"/>
          <Function name="vsnprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="18270A3F-B869-43FD-A094-8CAF6B58768A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="586"
              lineEnd="586" colStart="0" colEnd="0" snippet="stunnel.c:586:586"/>
          <Function name="memset"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1037"
              lineEnd="1037" colStart="0" colEnd="0" snippet="stunnel.c:1037:1037"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="557"
              lineEnd="557" colStart="0" colEnd="0" snippet="stunnel.c:557:557"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="551"
              lineEnd="551" colStart="0" colEnd="0" snippet="stunnel.c:551:551"/>
          <Function name="open"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="252"
              lineEnd="252" colStart="0" colEnd="0" snippet="stunnel.c:252:252"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="7467DE18-5588-416C-979E-CFCDBD24BE77">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="537"
              lineEnd="537" colStart="0" colEnd="0" snippet="stunnel.c:537:537"/>
          <Function name="snprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1043"
              lineEnd="1043" colStart="0" colEnd="0" snippet="stunnel.c:1043:1043"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="165"
              lineEnd="165" colStart="0" colEnd="0" snippet="stunnel.c:165:165"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="B6445DB1-42D0-4025-B4A9-071A23DCED66">
        <FunctionCall>
          <SourceLocation path="log.c" line="159"
              lineEnd="159" colStart="0" colEnd="0" snippet="log.c:159:159"/>
          <Function name="syslog"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="log.c" line="108"
              lineEnd="108" colStart="0" colEnd="0" snippet="log.c:108:108"/>
          <Function name="strtok"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1046"
              lineEnd="1046" colStart="0" colEnd="0" snippet="stunnel.c:1046:1046"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="18270A3F-B869-43FD-A094-8CAF6B58768A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="715"
              lineEnd="715" colStart="0" colEnd="0" snippet="stunnel.c:715:715"/>
          <Function name="memset"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1031"
              lineEnd="1031" colStart="0" colEnd="0" snippet="stunnel.c:1031:1031"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="327"
              lineEnd="327" colStart="0" colEnd="0" snippet="stunnel.c:327:327"/>
          <Function name="strrchr"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="568"
              lineEnd="568" colStart="0" colEnd="0" snippet="stunnel.c:568:568"/>
          <Function name="unlink"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="DFD1F0B7-9729-49C9-8558-46E615A8C296">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="164"
              lineEnd="164" colStart="0" colEnd="0" snippet="stunnel.c:164:164"/>
          <Function name="strncat"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="337"
              lineEnd="337" colStart="0" colEnd="0" snippet="stunnel.c:337:337"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1018"
              lineEnd="1018" colStart="0" colEnd="0" snippet="stunnel.c:1018:1018"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="164"
              lineEnd="164" colStart="0" colEnd="0" snippet="stunnel.c:164:164"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="8E4680BD-E2F0-4627-B8F1-BFEF1AB189F4">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="689"
              lineEnd="689" colStart="0" colEnd="0" snippet="stunnel.c:689:689"/>
          <Function name="putenv"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="535"
              lineEnd="535" colStart="0" colEnd="0" snippet="stunnel.c:535:535"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="DAE45D1C-5AC1-4FBF-9C0A-562A2CE5B482">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1007"
              lineEnd="1007" colStart="0" colEnd="0" snippet="stunnel.c:1007:1007"/>
          <Function name="malloc"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="18270A3F-B869-43FD-A094-8CAF6B58768A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="819"
              lineEnd="819" colStart="0" colEnd="0" snippet="stunnel.c:819:819"/>
          <Function name="memset"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1030"
              lineEnd="1030" colStart="0" colEnd="0" snippet="stunnel.c:1030:1030"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="DFD1F0B7-9729-49C9-8558-46E615A8C296">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="692"
              lineEnd="692" colStart="0" colEnd="0" snippet="stunnel.c:692:692"/>
          <Function name="strncat"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="B6725097-5284-4CB8-80B2-6D3C18058160">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="716"
              lineEnd="716" colStart="0" colEnd="0" snippet="ssl.c:716:716"/>
          <Function name="read"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="329"
              lineEnd="329" colStart="0" colEnd="0" snippet="stunnel.c:329:329"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="pty.c" line="255"
              lineEnd="255" colStart="0" colEnd="0" snippet="pty.c:255:255"/>
          <Function name="open"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="log.c" line="162"
              lineEnd="162" colStart="0" colEnd="0" snippet="log.c:162:162"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="log.c" line="124"
              lineEnd="124" colStart="0" colEnd="0" snippet="log.c:124:124"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="523"
              lineEnd="523" colStart="0" colEnd="0" snippet="stunnel.c:523:523"/>
          <Function name="strchr"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="331"
              lineEnd="331" colStart="0" colEnd="0" snippet="stunnel.c:331:331"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="pty.c" line="240"
              lineEnd="240" colStart="0" colEnd="0" snippet="pty.c:240:240"/>
          <Function name="open"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="7467DE18-5588-416C-979E-CFCDBD24BE77">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="769"
              lineEnd="769" colStart="0" colEnd="0" snippet="stunnel.c:769:769"/>
          <Function name="snprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="8E4680BD-E2F0-4627-B8F1-BFEF1AB189F4">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="693"
              lineEnd="693" colStart="0" colEnd="0" snippet="stunnel.c:693:693"/>
          <Function name="putenv"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="382"
              lineEnd="382" colStart="0" colEnd="0" snippet="ssl.c:382:382"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="384"
              lineEnd="384" colStart="0" colEnd="0" snippet="ssl.c:384:384"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="7467DE18-5588-416C-979E-CFCDBD24BE77">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="556"
              lineEnd="556" colStart="0" colEnd="0" snippet="stunnel.c:556:556"/>
          <Function name="sprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="14690628-80D2-4B94-9677-B69C71BF91AF">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="695"
              lineEnd="695" colStart="0" colEnd="0" snippet="stunnel.c:695:695"/>
          <Function name="execvp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="524"
              lineEnd="524" colStart="0" colEnd="0" snippet="ssl.c:524:524"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1017"
              lineEnd="1017" colStart="0" colEnd="0" snippet="stunnel.c:1017:1017"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="EB091198-21F7-4DE9-9784-AC0917616944">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="692"
              lineEnd="692" colStart="0" colEnd="0" snippet="stunnel.c:692:692"/>
          <Function name="strlen"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="249"
              lineEnd="249" colStart="0" colEnd="0" snippet="stunnel.c:249:249"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="B6725097-5284-4CB8-80B2-6D3C18058160">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="169"
              lineEnd="169" colStart="0" colEnd="0" snippet="protocol.c:169:169"/>
          <Function name="read"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="pty.c" line="227"
              lineEnd="227" colStart="0" colEnd="0" snippet="pty.c:227:227"/>
          <Function name="open"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="859"
              lineEnd="859" colStart="0" colEnd="0" snippet="stunnel.c:859:859"/>
          <Function name="strrchr"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="546"
              lineEnd="546" colStart="0" colEnd="0" snippet="stunnel.c:546:546"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1041"
              lineEnd="1041" colStart="0" colEnd="0" snippet="stunnel.c:1041:1041"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="797"
              lineEnd="797" colStart="0" colEnd="0" snippet="stunnel.c:797:797"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="267"
              lineEnd="267" colStart="0" colEnd="0" snippet="stunnel.c:267:267"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="7467DE18-5588-416C-979E-CFCDBD24BE77">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="145"
              lineEnd="145" colStart="0" colEnd="0" snippet="protocol.c:145:145"/>
          <Function name="vsnprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2FECE108-6EEE-4AC2-81FD-F030D8FD611D">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="434"
              lineEnd="434" colStart="0" colEnd="0" snippet="stunnel.c:434:434"/>
          <Function name="strncpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="98E689A0-F013-45A6-A7A6-F07E97179460">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="1033"
              lineEnd="1033" colStart="0" colEnd="0" snippet="stunnel.c:1033:1033"/>
          <Function name="fprintf"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="A5A573EC-B5AF-4A6F-B154-67856C9F29B6">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="60"
              lineEnd="60" colStart="0" colEnd="0" snippet="protocol.c:60:60"/>
          <Function name="strcmp"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="04139B1E-4D92-42C7-8888-156ED23703F6">
        <FunctionCall>
          <SourceLocation path="ssl.c" line="691"
              lineEnd="691" colStart="0" colEnd="0" snippet="ssl.c:691:691"/>
          <Function name="memcpy"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="2213BC0A-B324-4C8A-BFAD-0AD7FE480A6A">
        <FunctionCall>
          <SourceLocation path="stunnel.c" line="550"
              lineEnd="550" colStart="0" colEnd="0" snippet="stunnel.c:550:550"/>
          <Function name="unlink"/>
        </FunctionCall>
      </SinkInstance>
      <SinkInstance ruleID="28424EC3-FFAC-40C0-94D9-3D8283B2F57C">
        <FunctionCall>
          <SourceLocation path="protocol.c" line="186"
              lineEnd="186" colStart="0" colEnd="0" snippet="protocol.c:186:186"/>
          <Function name="sscanf"/>
        </FunctionCall>
      </SinkInstance>
    </Sinks>
    <CalledWithNoDef>
      <Function name="socket"/>
      <Function name="X509_STORE_get_by_subject"/>
      <Function name="SSL_CTX_set_client_CA_list"/>
      <Function name="pthread_self"/>
      <Function name="chmod"/>
      <Function name="SSL_want"/>
      <Function name="SSL_CTX_new"/>
      <Function name="bind"/>
      <Function name="CRYPTO_set_id_callback"/>
      <Function name="RAND_status"/>
      <Function name="pthread_mutex_lock"/>
      <Function name="SSL_CTX_ctrl"/>
      <Function name="pthread_attr_init"/>
      <Function name="daemon"/>
      <Function name="pthread_attr_setdetachstate"/>
      <Function name="setsockopt"/>
      <Function name="CRYPTO_set_locking_callback"/>
      <Function name="listen"/>
      <Function name="SSL_set_session_id_context"/>
      <Function name="SSL_CTX_use_RSAPrivateKey_file"/>
      <Function name="signal"/>
      <Function name="pthread_create"/>
      <Function name="SSL_set_session"/>
      <Function name="getpid"/>
      <Function name="openpty"/>
      <Function name="SSL_set_shutdown"/>
      <Function name="log"/>
      <Function name="getsockname"/>
      <Function name="sigemptyset"/>
      <Function name="SSL_set_fd"/>
      <Function name="SSL_connect"/>
      <Function name="SSL_library_init"/>
      <Function name="SSL_new"/>
      <Function name="SSL_CTX_set_default_verify_paths"/>
      <Function name="SSL_state_string_long"/>
      <Function name="RAND_write_file"/>
      <Function name="fork"/>
      <Function name="SSL_load_client_CA_file"/>
      <Function name="SSL_load_error_strings"/>
      <Function name="SSL_CTX_set_tmp_rsa_callback"/>
      <Function name="SSL_set_accept_state"/>
      <Function name="SSL_set_connect_state"/>
      <Function name="exit"/>
      <Function name="SSL_free"/>
      <Function name="SSL_get_fd"/>
      <Function name="SSL_CTX_load_verify_locations"/>
      <Function name="RAND_file_name"/>
      <Function name="select"/>
      <Function name="htons"/>
      <Function name="SSL_CTX_set_verify"/>
      <Function name="SSL_get_error"/>
      <Function name="htonl"/>
      <Function name="RSA_free"/>
      <Function name="ntohs"/>
      <Function name="connect"/>
      <Function name="write"/>
      <Function name="closelog"/>
      <Function name="SSL_write"/>
      <Function name="ERR_error_string"/>
      <Function name="inet_ntoa"/>
      <Function name="SSL_CTX_use_certificate_file"/>
      <Function name="openlog"/>
      <Function name="strerror"/>
      <Function name="SSLv23_server_method"/>
      <Function name="pthread_mutex_init"/>
      <Function name="setgid"/>
      <Function name="SSL_pending"/>
      <Function name="X509_get_subject_name"/>
      <Function name="SSL_read"/>
      <Function name="wait"/>
      <Function name="atexit"/>
      <Function name="SSLv3_client_method"/>
      <Function name="sigaddset"/>
      <Function name="free"/>
      <Function name="fflush"/>
      <Function name="SSL_get_current_cipher"/>
      <Function name="SSL_accept"/>
      <Function name="time"/>
      <Function name="X509_NAME_oneline"/>
      <Function name="chown"/>
      <Function name="inet_addr"/>
      <Function name="ioctl"/>
      <Function name="ERR_remove_state"/>
      <Function name="RAND_load_file"/>
      <Function name="SSL_CTX_check_private_key"/>
      <Function name="SSL_CTX_free"/>
      <Function name="ERR_get_error"/>
      <Function name="RSA_generate_key"/>
      <Function name="pthread_mutex_unlock"/>
      <Function name="setsid"/>
      <Function name="dup2"/>
      <Function name="__xstat"/>
      <Function name="X509_verify_cert_error_string"/>
      <Function name="SSL_CIPHER_get_bits"/>
      <Function name="close"/>
      <Function name="SSL_CIPHER_get_name"/>
      <Function name="setuid"/>
      <Function name="accept"/>
      <Function name="__ctype_b_loc"/>
      <Function name="SSL_CTX_set_timeout"/>
      <Function name="SSL_CTX_set_cipher_list"/>
      <Function name="pthread_sigmask"/>
      <Function name="__errno_location"/>
      <Function name="RAND_egd"/>
    </CalledWithNoDef>
  </ProgramData>
  <EngineData>
    <EngineVersion>3.1.0106</EngineVersion>
    <InactiveResults/>
    <RulePacks>
      <RulePack>Fortify Secure Coding Rules, Extended, Configuration</RulePack>
      <RulePack>Fortify Secure Coding Rules, Extended, C/C++</RulePack>
      <RulePack>Fortify Secure Coding Rules, Core, C/C++</RulePack>
    </RulePacks>
    <ExpiredRulePacks/>
    <UnlicensedRulePacks/>
  </EngineData>
</FVDL>
